# PySNMP SMI module. Autogenerated from smidump -f python CISCO-ENHANCED-MEMPOOL-MIB
# by libsmi2pysnmp-0.1.3 at Mon Dec  7 11:59:57 2015,
# Python version sys.version_info(major=2, minor=7, micro=9, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( entPhysicalIndex, ) = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
( CounterBasedGauge64, ) = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( AutonomousType, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "AutonomousType", "TextualConvention", "TimeStamp", "TruthValue")

# Types

class CempMemBufferPoolIndex(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(1,4294967295)
    
class CempMemPoolIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,2147483647)
    
class CempMemPoolIndexOrNone(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,2147483647)
    
class CempMemPoolTypes(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(10,8,4,5,2,3,6,1,13,12,9,11,7,14,)
    namedValues = NamedValues(("other", 1), ("virtualMemory", 10), ("reservedMemory", 11), ("imageMemory", 12), ("asicMemory", 13), ("posixMemory", 14), ("processorMemory", 2), ("ioMemory", 3), ("pciMemory", 4), ("fastMemory", 5), ("multibusMemory", 6), ("interruptStackMemory", 7), ("processStackMemory", 8), ("localExceptionMemory", 9), )
    

# Objects

ciscoEnhancedMemPoolMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 221)).setRevisions(("2008-12-05 00:00","2008-05-07 00:00","2003-02-24 00:00","2001-06-05 00:00",))
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setOrganization("Cisco Systems, Inc.")
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setContactInfo("Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-memory@cisco.com")
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setDescription("New MIB module for monitoring the memory pools\nof all physical entities on a managed system.")
cempMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 0))
cempMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1))
cempMemPool = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1))
cempMemPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1))
if mibBuilder.loadTexts: cempMemPoolTable.setDescription("A table of memory pool monitoring entries for all\nphysical entities on a managed system.")
cempMemPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1)).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolIndex"))
if mibBuilder.loadTexts: cempMemPoolEntry.setDescription("An entry in the memory pool monitoring table.")
cempMemPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 1), CempMemPoolIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cempMemPoolIndex.setDescription("Within each physical entity, the unique value\ngreater than zero, used to represent each memory pool.  \nIt is recommended that values are assigned\ncontiguously starting from 1.")
cempMemPoolType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 2), CempMemPoolTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolType.setDescription("The type of memory pool for which this entry\ncontains information.")
cempMemPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolName.setDescription("A textual name assigned to the memory pool. This\nobject is suitable for output to a human operator,\nand may also be used to distinguish among the various\npool types.")
cempMemPoolPlatformMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 4), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolPlatformMemory.setDescription("An indication of the platform-specific memory\npool type. The associated instance of cempMemPoolType\nis used to indicate the general type of memory pool.\n\nIf no platform specific memory hardware type\nidentifier exists for this physical entity, or the\nvalue is unknown by this agent, then the value { 0 0 }\nis returned.")
cempMemPoolAlternate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 5), CempMemPoolIndexOrNone()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAlternate.setDescription("Indicates whether or not this memory pool has an\nalternate pool configured.  Alternate pools are\nused for fallback when the current pool runs out\nof memory.\n\nIf an instance of this object has a value of zero,\nthen this pool does not have an alternate.  Otherwise\nthe value of this object is the same as the value of\ncempMemPoolType of the alternate pool.")
cempMemPoolValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolValid.setDescription("Indicates whether or not cempMemPoolUsed,\ncempMemPoolFree, cempMemPoolLargestFree and \ncempMemPoolLowestFree in this entry contain accurate \ndata. If an instance of this object has the value \nfalse (which in and of itself indicates an internal \nerror condition), the values of these objects\nin the conceptual row may contain inaccurate \ninformation (specifically, the reported values may be \nless than the actual values).")
cempMemPoolUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsed.setDescription("Indicates the number of bytes from the memory pool\nthat are currently in use by applications on the\nphysical entity.")
cempMemPoolFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFree.setDescription("Indicates the number of bytes from the memory pool\nthat are currently unused on the physical entity.\n\nNote that the sum of cempMemPoolUsed and cempMemPoolFree \nis the total amount of memory in the pool")
cempMemPoolLargestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLargestFree.setDescription("Indicates the largest number of contiguous bytes\nfrom the memory pool that are currently unused on\nthe physical entity.")
cempMemPoolLowestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLowestFree.setDescription("The lowest amount of available memory in the memory pool\nrecorded at any time during the operation of the system.")
cempMemPoolUsedLowWaterMark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMark.setDescription("Indicates the lowest number of bytes from the memory pool\nthat have been used by applications on the physical entity\nsince sysUpTime.Similarly,the Used High\nWatermark indicates the largest number of bytes from\nthe memory pool that have been used by applications on\nthe physical entity since sysUpTime.This can be\nderived as follows:\nUsed High Watermark = cempMemPoolUsed +\ncempMemPoolFree  - cempMemPoolLowestFree.")
cempMemPoolAllocHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAllocHit.setDescription("Indicates the number of successful allocations from\nthe memory pool")
cempMemPoolAllocMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAllocMiss.setDescription("Indicates the number of unsuccessful allocations from\nthe memory pool")
cempMemPoolFreeHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeHit.setDescription("Indicates the number of successful frees/\ndeallocations from the memory pool")
cempMemPoolFreeMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeMiss.setDescription("Indicates the number of unsuccessful attempts\nto free/deallocate memory from the memory pool.\nFor example, this could be due to ownership errors \nwhere the application that did not assign the \nmemory is trying to free it.")
cempMemPoolShared = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolShared.setDescription("Indicates the number of bytes from the memory pool\nthat are currently shared on the physical entity.")
cempMemPoolUsedOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedOvrflw.setDescription("This object represents the upper 32-bits of cempMemPoolUsed.\nThis object needs to be supported only if the used bytes in the\nmemory pool exceeds 32-bits, otherwise this object value would\nbe set to 0.")
cempMemPoolHCUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 18), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCUsed.setDescription("Indicates the number of bytes from the memory pool\nthat are currently in use by applications on the\nphysical entity. This object is a 64-bit version of\ncempMemPoolUsed.")
cempMemPoolFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeOvrflw.setDescription("This object represents the upper 32-bits of cempMemPoolFree.\nThis object needs to be supported only if the unused bytes in\nthe memory pool exceeds 32-bits, otherwise this object value\nwould be set to 0.")
cempMemPoolHCFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 20), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCFree.setDescription("Indicates the number of bytes from the memory pool\nthat are currently unused on the physical entity.\nThis object is a 64-bit version of cempMemPoolFree.")
cempMemPoolLargestFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLargestFreeOvrflw.setDescription("This object represents the upper 32-bits of\ncempMemPoolLargestFree. This object needs to \nbe supported only if the value of \ncempMemPoolLargestFree exceeds 32-bits, otherwise\nthis object value would be set to 0.")
cempMemPoolHCLargestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 22), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCLargestFree.setDescription("Indicates the largest number of contiguous bytes from the\nmemory pool that are currently unused on the physical entity.\nThis object is a 64-bit version of cempMemPoolLargestFree.")
cempMemPoolLowestFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLowestFreeOvrflw.setDescription("This object represents the upper 32-bits of\ncempMemPoolLowestFree. This object needs to\nbe supported only if the value of\ncempMemPoolLowestFree exceeds 32-bits, otherwise\nthis object value would be set to 0.")
cempMemPoolHCLowestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 24), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCLowestFree.setDescription("The lowest amount of available memory in the memory pool\nrecorded at any time during the operation of the system.\nThis object is a 64-bit version of cempMemPoolLowestFree.")
cempMemPoolUsedLowWaterMarkOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMarkOvrflw.setDescription("This object represents the upper 32-bits of\ncempMemPoolUsedLowWaterMark. This object\nneeds to be supported only if the value of\ncempMemPoolUsedLowWaterMark exceeds 32-bits,\notherwise this object value would be set to 0.")
cempMemPoolHCUsedLowWaterMark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 26), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCUsedLowWaterMark.setDescription("Indicates the lowest number of bytes from the memory\npool that have been used by applications on the physical\nentity since sysUpTime. This object is a 64-bit version\nof cempMemPoolUsedLowWaterMark.")
cempMemPoolSharedOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolSharedOvrflw.setDescription("This object represents the upper 32-bits of cempMemPoolShared.\nThis object needs to be supported only if the value of\ncempMemPoolShared exceeds 32-bits, otherwise this object value\nwould be set to 0.")
cempMemPoolHCShared = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 28), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCShared.setDescription("Indicates the number of bytes from the memory pool that are\ncurrently shared on the physical entity. This object is a\n64-bit version of cempMemPoolShared.")
cempMemBufferPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2))
if mibBuilder.loadTexts: cempMemBufferPoolTable.setDescription("Entries in this table define entities (buffer pools\nin this case) which are contained in an entity \n(memory pool) defined by an entry from\ncempMemPoolTable.\n-- Basic Pool Architecture --\n1)Pools are classified as being either Static or \n  Dynamic. Static pools make no attempt to increase \n  the number of buffers contained within them if the \n  number of free buffers (cempMemBufferFree) are less\n  than the number of minimum buffers (cempMemBufferMin).\n  With Dynamic pools, the pool attempts to meet the \n  demands of its users.\n2)Buffers in a pool are classified as being either \n  Permanent or Temporary. Permanent buffers, as their\n  name suggests, are always in the pool and are never\n  destroyed unless the number of permanent buffers \n  (cempMemBufferPermanent) is changed. Temporary\n  buffers are transient buffers that are created in\n  dynamic pools whenever the free count \n  (cempMemBufferFree) of buffers in the pool drops \n  below the minimum (cempMemBufferMin).\n3)Buffers pools are classified as either Public or \n  Private. Public pools are available for all users \n  to allocate buffers from. Private pools are\n  primarily used by interface drivers.")
cempMemBufferPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1)).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPoolIndex"))
if mibBuilder.loadTexts: cempMemBufferPoolEntry.setDescription("This contains all the memory buffer pool\nconfigurations object values. The \nentPhysicalIndex identifies the entity on which\nmemory buffer pools are present.")
cempMemBufferPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 1), CempMemBufferPoolIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cempMemBufferPoolIndex.setDescription("Within a physical entity, a unique value used\nto represent each buffer pool.")
cempMemBufferMemPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 2), CempMemPoolIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferMemPoolIndex.setDescription("This index corresponds to the memory pool (with\ncemMemPoolIndex as index in cempMemPoolTable) \nfrom which buffers are allocated.")
cempMemBufferName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferName.setDescription("A textual name assigned to the buffer pool. This\nobject is suitable for output to a human operator,\nand may also be used to distinguish among the various\nbuffer types.\nFor example: 'Small', 'Big', 'Serial0/1' etc.")
cempMemBufferDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferDynamic.setDescription("Boolean poolDynamic; if TRUE, the number of buffers\nin the pool is adjusted (adding more packet buffers \nor deleting excesses) dynamically by the background \nprocess. If FALSE, the number of buffers in the pool \nis never adjusted, even if it falls below the minimum,\nor to zero.")
cempMemBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferSize.setDescription("Indicates the size of buffer element in number of bytes\non the physical entity.")
cempMemBufferMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferMin.setDescription("Indicates the minimum number of free buffers\nallowed in the buffer pool or low-water mark (lwm). \nFor example of its usage :\nIf cempMemBufferFree < cempMemBufferMin & pool is \ndynamic, then signal for growth of particular buffer\npool.")
cempMemBufferMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferMax.setDescription("Indicates the maximum number of free buffers\nallowed in the buffer pool or high-water mark (hwm).\nFor example of its usage :\nIf cempMemBufferFree > cempMemBufferMax & pool is \ndynamic, then signal for trim of particular buffer\npool.")
cempMemBufferPermanent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferPermanent.setDescription("Indicates the total number of permanent buffers in the\npool on the physical entity.")
cempMemBufferTransient = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferTransient.setDescription("Indicates the initial number of temporary buffers\nin the pool on the physical entity. This object \ninstructs the system to create this many number of\ntemporary extra buffers, just after a system restart. \nA change in this object will be effective only after\na system restart.")
cempMemBufferTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferTotal.setDescription("Indicates the total number of buffers\n(include allocated and free buffers) in the\nbuffer pool on the physical entity.")
cempMemBufferFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFree.setDescription("Indicates the current number of free buffers in\nthe buffer pool on the physical entity.\nNote that the cempMemBufferFree is less than or equal \nto cempMemBufferTotal.")
cempMemBufferHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferHit.setDescription("Indicates the number of buffers successfully\nallocated from the buffer pool.")
cempMemBufferMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferMiss.setDescription("Indicates the number of times a buffer has been\nrequested, but no buffers were available in the\nbuffer pool, or when there were fewer than min \nbuffers(cempMemBufferMin) in the buffer pool.\nNote : For interface pools, a miss is actually \na fall back to its corresponding public buffer pool.")
cempMemBufferFreeHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFreeHit.setDescription("Indicates the number of successful frees/deallocations\nfrom the buffer pool.")
cempMemBufferFreeMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFreeMiss.setDescription("Indicates the number of unsuccessful attempts\nto free/deallocate a buffer from the buffer pool. \nFor example, this could be due to ownership errors\nwhere the application that did not assign the \nbuffer is trying to free it.")
cempMemBufferPermChange = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPermChange.setDescription("This value is the difference of the desired number\nof permanent buffer & total number of permanent \nbuffers present in the pool. A positive value of \nthis object tells the number of buffers needed & a \nnegative value of the object tells the extra number \nof buffers in the pool.")
cempMemBufferPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPeak.setDescription("Indicates the peak number of buffers in pool on the\nphysical entity.")
cempMemBufferPeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPeakTime.setDescription("Indicates the time of most recent change in the peak\nnumber of buffers (cempMemBufferPeak object) in the pool.")
cempMemBufferTrim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferTrim.setDescription("The number of buffers that have been trimmed from the\npool when the number of free buffers \n(cempMemBufferFree) exceeded the number of max\nallowed buffers(cempMemBufferMax).")
cempMemBufferGrow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferGrow.setDescription("The number of buffers that have been created in the\npool when the number of free buffers(cempMemBufferFree)\nwas less than minimum(cempMemBufferMix).")
cempMemBufferFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFailures.setDescription("The number of failures to grant a buffer to a\nrequester due to reasons other than insufficient \nmemory. For example, in systems where there are \ndifferent execution contexts, it may be too\nexpensive to create new buffers when running in\ncertain contexts. In those cases it may be \npreferable to fail the request.")
cempMemBufferNoStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferNoStorage.setDescription("The number of times the system tried to create new\nbuffers, but could not due to insufficient free \nmemory in the system.")
cempMemBufferCachePoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3))
if mibBuilder.loadTexts: cempMemBufferCachePoolTable.setDescription("A table that lists the cache buffer pools\nconfigured on a managed system. \n1)To provide a noticeable performance boost, \n  Cache Pool can be used. A Cache Pool is effectively\n  a lookaside list of free buffers that can be \n  accessed quickly. Cache Pool is tied to Buffer Pool. \n2)Cache pools can optionally have a threshold value\n  on the number of cache buffers used in a pool. This\n  can provide flow control management by having a \n  implementation specific approach such as invoking a\n  vector when pool cache rises above the optional \n  threshold set for it on creation.")
cempMemBufferCachePoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1)).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPoolIndex"))
if mibBuilder.loadTexts: cempMemBufferCachePoolEntry.setDescription("Each entry represents one of the cache buffer pools\navailable in the system and it contains the\nparameters configured for it.\nNote : cempMemBufferCachePoolTable has a sparse\ndependency with cempMemBufferPoolTable (i.e all the\nentires in cempMemBufferPoolTable need not have an\nentry in cempMemBufferCachePoolTable.")
cempMemBufferCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheSize.setDescription("Indicates the number of buffers in the cache pool\non the physical entity.")
cempMemBufferCacheTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheTotal.setDescription("Indicates the maximum number of free buffers\nallowed in the cache pool.")
cempMemBufferCacheUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheUsed.setDescription("Indicates the number of cache buffers from the\npool that are currently used on the physical entity.\nNote that the cempMemBufferCacheUsed is less than or \nequal to cempMemBufferCacheTotal.")
cempMemBufferCacheHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheHit.setDescription("Indicates the number of buffers successfully\nallocated from the cache pool.")
cempMemBufferCacheMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheMiss.setDescription("Indicates the number of times a buffer has been\nrequested, but no buffers were available in the\ncache pool.")
cempMemBufferCacheThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheThreshold.setDescription("Indicates the threshold limit for number of cache\nbuffers used(cempMemBufferCacheUsed).")
cempMemBufferCacheThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheThresholdCount.setDescription("Indicates how many times the number of cache\nbuffers used(cempMemBufferCacheUsed) has crossed the\nthreshold value(cempMemBufferCacheThreshold).")
cempNotificationConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 2))
cempMemBufferNotifyEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 2, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferNotifyEnabled.setDescription("This variable controls generation of the\ncempMemBufferNotify.\n\nWhen this variable is 'true', generation of\ncempMemBufferNotify is enabled.  When this variable\nis 'false', generation of cempMemBufferNotify\nis disabled.")
cempMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3))
cempMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1))
cempMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2))

# Augmentions

# Notifications

cempMemBufferNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 221, 0, 1)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeak"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeakTime"), ) )
if mibBuilder.loadTexts: cempMemBufferNotify.setDescription("Whenever cempMemBufferPeak object is updated in the\nbuffer pool, a cempMemBufferNotify notification\nis sent. The sending of these notifications can be \nenabled/disabled via the cempMemBufferNotifyEnabled object.")

# Groups

cempMemPoolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 1)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolValid"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolType"), ) )
if mibBuilder.loadTexts: cempMemPoolGroup.setDescription("A collection of objects providing memory pool\nmonitoring.")
cempMemPoolExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 2)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolPlatformMemory"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAlternate"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFree"), ) )
if mibBuilder.loadTexts: cempMemPoolExtGroup.setDescription("A collection of objects providing additional memory\npool information. This group is deprecated as new \nobjects cempMemPoolUsedLowWaterMark,\ncempMemPoolAllocHit, cempMemPoolAllocMiss, \ncempMemPoolFreeHit, cempMemPool are being added.\nA new group cempMemPoolExtGroupRev1 is being added in\nit's place.")
cempMemBufferGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 3)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTransient"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferDynamic"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPermChange"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMax"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTrim"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMin"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNoStorage"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferSize"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFreeHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTotal"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPermanent"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFailures"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeak"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMemPoolIndex"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeakTime"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGrow"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFreeMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFree"), ) )
if mibBuilder.loadTexts: cempMemBufferGroup.setDescription("A collection of objects providing memory buffer pool\nmonitoring.")
cempMemBufferExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 4)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheThresholdCount"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheThreshold"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheSize"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheTotal"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheMiss"), ) )
if mibBuilder.loadTexts: cempMemBufferExtGroup.setDescription("A collection of objects providing additional memory\nbuffer pool monitoring.")
cempMemBufferNotifyEnableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 5)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnabled"), ) )
if mibBuilder.loadTexts: cempMemBufferNotifyEnableGroup.setDescription("A group of objects related to enabling notifications.")
cempMemBufferNotifyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 6)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotify"), ) )
if mibBuilder.loadTexts: cempMemBufferNotifyGroup.setDescription("A group of notifications providing additional\nmemory buffer pool monitoring.")
cempMemPoolExtGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 7)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedLowWaterMark"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAllocMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolPlatformMemory"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAlternate"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAllocHit"), ) )
if mibBuilder.loadTexts: cempMemPoolExtGroupRev1.setDescription("A group of objects providing additional memory\npool information.This group deprecates \ncempMemPoolExtGroup.")
cempMemPoolGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 8)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolShared"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolValid"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolType"), ) )
if mibBuilder.loadTexts: cempMemPoolGroupRev1.setDescription("A collection of objects providing memory pool\nmonitoring. This group deprecates \ncempMemPoolGroup.")
cempMemPoolHCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 9)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCLowestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCUsedLowWaterMark"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCShared"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCUsed"), ) )
if mibBuilder.loadTexts: cempMemPoolHCGroup.setDescription("A collection of High Capacity(HC) objects providing memory pool\nmonitoring.")
cempMemPoolOvrflwGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 10)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolSharedOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedLowWaterMarkOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFreeOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFreeOvrflw"), ) )
if mibBuilder.loadTexts: cempMemPoolOvrflwGroup.setDescription("A collection of Overflow (Ovrflw) objects providing memory pool\nmonitoring.")

# Compliances

cempMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 1)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroup"), ) )
if mibBuilder.loadTexts: cempMIBCompliance.setDescription("The compliance statement for entities which\nimplement the Cisco Enhanced MemPool MIB.")
cempMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 2)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ) )
if mibBuilder.loadTexts: cempMIBComplianceRev1.setDescription("The compliance statement for entities which\nimplement the Cisco Enhanced MemPool MIB.\nThis compliance module deprecates \ncempMIBCompliance.")
cempMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 3)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ) )
if mibBuilder.loadTexts: cempMIBComplianceRev2.setDescription("The compliance statement for entities which\nimplement the Cisco Enhanced MemPool MIB.\nThis compliance module deprecates \ncempMIBComplianceRev1.")
cempMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 4)).setObjects(*(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolOvrflwGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ) )
if mibBuilder.loadTexts: cempMIBComplianceRev3.setDescription("The compliance statement for entities which\nimplement the Cisco Enhanced MemPool MIB.\nThis compliance module deprecates \ncempMIBComplianceRev2.")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", PYSNMP_MODULE_ID=ciscoEnhancedMemPoolMIB)

# Types
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", CempMemBufferPoolIndex=CempMemBufferPoolIndex, CempMemPoolIndex=CempMemPoolIndex, CempMemPoolIndexOrNone=CempMemPoolIndexOrNone, CempMemPoolTypes=CempMemPoolTypes)

# Objects
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", ciscoEnhancedMemPoolMIB=ciscoEnhancedMemPoolMIB, cempMIBNotifications=cempMIBNotifications, cempMIBObjects=cempMIBObjects, cempMemPool=cempMemPool, cempMemPoolTable=cempMemPoolTable, cempMemPoolEntry=cempMemPoolEntry, cempMemPoolIndex=cempMemPoolIndex, cempMemPoolType=cempMemPoolType, cempMemPoolName=cempMemPoolName, cempMemPoolPlatformMemory=cempMemPoolPlatformMemory, cempMemPoolAlternate=cempMemPoolAlternate, cempMemPoolValid=cempMemPoolValid, cempMemPoolUsed=cempMemPoolUsed, cempMemPoolFree=cempMemPoolFree, cempMemPoolLargestFree=cempMemPoolLargestFree, cempMemPoolLowestFree=cempMemPoolLowestFree, cempMemPoolUsedLowWaterMark=cempMemPoolUsedLowWaterMark, cempMemPoolAllocHit=cempMemPoolAllocHit, cempMemPoolAllocMiss=cempMemPoolAllocMiss, cempMemPoolFreeHit=cempMemPoolFreeHit, cempMemPoolFreeMiss=cempMemPoolFreeMiss, cempMemPoolShared=cempMemPoolShared, cempMemPoolUsedOvrflw=cempMemPoolUsedOvrflw, cempMemPoolHCUsed=cempMemPoolHCUsed, cempMemPoolFreeOvrflw=cempMemPoolFreeOvrflw, cempMemPoolHCFree=cempMemPoolHCFree, cempMemPoolLargestFreeOvrflw=cempMemPoolLargestFreeOvrflw, cempMemPoolHCLargestFree=cempMemPoolHCLargestFree, cempMemPoolLowestFreeOvrflw=cempMemPoolLowestFreeOvrflw, cempMemPoolHCLowestFree=cempMemPoolHCLowestFree, cempMemPoolUsedLowWaterMarkOvrflw=cempMemPoolUsedLowWaterMarkOvrflw, cempMemPoolHCUsedLowWaterMark=cempMemPoolHCUsedLowWaterMark, cempMemPoolSharedOvrflw=cempMemPoolSharedOvrflw, cempMemPoolHCShared=cempMemPoolHCShared, cempMemBufferPoolTable=cempMemBufferPoolTable, cempMemBufferPoolEntry=cempMemBufferPoolEntry, cempMemBufferPoolIndex=cempMemBufferPoolIndex, cempMemBufferMemPoolIndex=cempMemBufferMemPoolIndex, cempMemBufferName=cempMemBufferName, cempMemBufferDynamic=cempMemBufferDynamic, cempMemBufferSize=cempMemBufferSize, cempMemBufferMin=cempMemBufferMin, cempMemBufferMax=cempMemBufferMax, cempMemBufferPermanent=cempMemBufferPermanent, cempMemBufferTransient=cempMemBufferTransient, cempMemBufferTotal=cempMemBufferTotal, cempMemBufferFree=cempMemBufferFree, cempMemBufferHit=cempMemBufferHit, cempMemBufferMiss=cempMemBufferMiss, cempMemBufferFreeHit=cempMemBufferFreeHit, cempMemBufferFreeMiss=cempMemBufferFreeMiss, cempMemBufferPermChange=cempMemBufferPermChange, cempMemBufferPeak=cempMemBufferPeak, cempMemBufferPeakTime=cempMemBufferPeakTime, cempMemBufferTrim=cempMemBufferTrim, cempMemBufferGrow=cempMemBufferGrow, cempMemBufferFailures=cempMemBufferFailures, cempMemBufferNoStorage=cempMemBufferNoStorage, cempMemBufferCachePoolTable=cempMemBufferCachePoolTable, cempMemBufferCachePoolEntry=cempMemBufferCachePoolEntry, cempMemBufferCacheSize=cempMemBufferCacheSize, cempMemBufferCacheTotal=cempMemBufferCacheTotal, cempMemBufferCacheUsed=cempMemBufferCacheUsed, cempMemBufferCacheHit=cempMemBufferCacheHit, cempMemBufferCacheMiss=cempMemBufferCacheMiss, cempMemBufferCacheThreshold=cempMemBufferCacheThreshold, cempMemBufferCacheThresholdCount=cempMemBufferCacheThresholdCount, cempNotificationConfig=cempNotificationConfig, cempMemBufferNotifyEnabled=cempMemBufferNotifyEnabled, cempMIBConformance=cempMIBConformance, cempMIBCompliances=cempMIBCompliances, cempMIBGroups=cempMIBGroups)

# Notifications
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", cempMemBufferNotify=cempMemBufferNotify)

# Groups
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", cempMemPoolGroup=cempMemPoolGroup, cempMemPoolExtGroup=cempMemPoolExtGroup, cempMemBufferGroup=cempMemBufferGroup, cempMemBufferExtGroup=cempMemBufferExtGroup, cempMemBufferNotifyEnableGroup=cempMemBufferNotifyEnableGroup, cempMemBufferNotifyGroup=cempMemBufferNotifyGroup, cempMemPoolExtGroupRev1=cempMemPoolExtGroupRev1, cempMemPoolGroupRev1=cempMemPoolGroupRev1, cempMemPoolHCGroup=cempMemPoolHCGroup, cempMemPoolOvrflwGroup=cempMemPoolOvrflwGroup)

# Compliances
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", cempMIBCompliance=cempMIBCompliance, cempMIBComplianceRev1=cempMIBComplianceRev1, cempMIBComplianceRev2=cempMIBComplianceRev2, cempMIBComplianceRev3=cempMIBComplianceRev3)
