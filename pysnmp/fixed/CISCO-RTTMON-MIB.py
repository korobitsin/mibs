# PySNMP SMI module. Autogenerated from smidump -f python CISCO-RTTMON-MIB
# by libsmi2pysnmp-0.1.3 at Mon Dec  7 11:16:58 2015,
# Python version sys.version_info(major=2, minor=7, micro=9, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( CfmMepid, ) = mibBuilder.importSymbols("CISCO-ETHER-CFM-MIB", "CfmMepid")
( QosLayer2Cos, ) = mibBuilder.importSymbols("CISCO-QOS-PIB-MIB", "QosLayer2Cos")
( RttMonCodecType, RttMonLSPPingReplyMode, RttMonOperation, RttMonProtocol, RttMonReactVar, RttMonRttType, RttMonTargetAddress, RttMplsVpnMonLpdFailureSense, RttMplsVpnMonLpdGrpStatus, RttMplsVpnMonRttType, RttReset, RttResponseSense, ) = mibBuilder.importSymbols("CISCO-RTTMON-TC-MIB", "RttMonCodecType", "RttMonLSPPingReplyMode", "RttMonOperation", "RttMonProtocol", "RttMonReactVar", "RttMonRttType", "RttMonTargetAddress", "RttMplsVpnMonLpdFailureSense", "RttMplsVpnMonLpdGrpStatus", "RttMplsVpnMonRttType", "RttReset", "RttResponseSense")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( Dscp, ) = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( VlanId, ) = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( DisplayString, MacAddress, RowStatus, StorageType, TimeInterval, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "RowStatus", "StorageType", "TimeInterval", "TimeStamp", "TruthValue")

# Objects

ciscoRttMonMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 42)).setRevisions(("2012-08-16 00:00","2011-09-15 00:00","2011-02-21 00:00","2010-10-18 00:00","2010-06-04 00:00","2009-04-07 00:00","2008-03-24 00:00","2008-01-06 00:00","2006-12-08 00:00","2006-06-08 00:00","2006-03-02 00:00","2005-08-11 00:00","2005-04-21 00:00","2005-01-04 00:00","2004-08-26 00:00","2004-05-18 00:00","2004-01-20 00:00","2003-08-11 00:00","2003-05-21 00:00","2003-04-15 00:00","2003-03-12 00:00","2000-11-03 00:00","1999-06-15 00:00",))
if mibBuilder.loadTexts: ciscoRttMonMIB.setOrganization("Cisco IOS")
if mibBuilder.loadTexts: ciscoRttMonMIB.setContactInfo("Cisco Systems, Inc.\nCustomer Service \n\nPostal: 170 W Tasman Drive\nSan Jose, CA 95134\n\nTel: +1 800 553 NETS\n\ncs-ipsla@cisco.com")
if mibBuilder.loadTexts: ciscoRttMonMIB.setDescription("This module defines a MIB for Round Trip Time\n(RTT) monitoring of a list of targets, using a \nvariety of protocols.\n\nThe table structure overview is a follows (t: \n indicates a table, at:  indicates an augmented \n table, and it:  indicates table with the same \n indices/control as parent table):\n\nRTTMON MIB\n|--- Application Group\n|    |--- Application Identity\n|    |--- Application Capabilities\n|    |--- Application Reset\n|    |t-- Supported RTT Types\n|         |--- Truth Value\n|    |t-- Supported Protocols\n|         |--- Truth Value\n|    |t-- Application Preconfigured\n|         |--- Script Names\n|         |--- File Paths\n|    |--- Responder control\n|    |t-- Control Protocol Authentication\n|\n|--- Overall Control Group\n|    |t-- Master Definitions Table\n|    |    |--- Global Configuration Definitions\n|    |         |--- Config for a single RTT Life\n|    |    |it- Echo Specific Configuration\n|    |    |it- Echo Path Hop Address Configuration\n|    |    |it- File I/O Specific Configuration\n|    |    |it- Script Specific Configuration\n|    |    |at- Schedule Configuration\n|    |    |at- Reaction Specific Config\n|    |    |at- Statistics Capture Configuration\n|    |    |at- History Collection Configuration\n|    |    |at- Monitoring Operational State\n|    |    |at- Last RTT operation\n|    |\n|    |t-- Reaction Trigger Table\n|         |at- Reaction Trigger Operational State\n|\n|--- Statistics Collection Group\n|    |t-- Statistics Capture Table\n|         |--- Captured Statistics\n|              |--- Path Information\n|              |--- Distribution Capture \n|              |--- Mean and Deviation Capture\n|         |it- Statistics Collection Table\n|    |it- Statistics Totals Table\n|    |t-- HTTP Stats Table\n|    |t-- Jitter Stats Table\n|\n|--- History Collection Group\n|    |t-- History Collection Table\n|         |-- Path Information\n|         |-- Completion Information per operation\n|\n|--- Latest Operation Group\n|    |t-- Latest HTTP Oper Table\n|    |t-- Latest Jitter Oper Table\n\nDEFINITIONS:\n  conceptual RTT control row - \n          This is a row in the 'Overall Control \n          Group'.  This row is indexed via the \n          rttMonCtrlAdminIndex object.  This row \n          is spread across multiple real tables \n          in the 'Overall Control Group'.\n  probe -\n          This is the entity that executes via a \n          conceptual RTT control row and populates\n          a conceptual statistics row and a \n          conceptual history row.\n  Rtt operation -\n          This is a single operation performed by\n          a probe.  This operation can be a single\n          Rtt attempt/completion or a group of Rtt\n          attempts/completions that produce one\n          operation table entry.\n\nARR Protocol Definition:\n\nThe format of the RTT Asymmetric Request/Responses \n (ARR) protocol is as follows:\n\n  The ARR Header (total of 12 octets): \n\n  4 octet -> eyecatcher: 'WxYz'\n  1 octet -> version   : 0x01 - protocol version\n  1 octet -> command   : 0x01 - logoff request\n                         0x02 - echo request\n                         0x03 - echo response\n                         0x04 - software version request\n                         0x05 - software version response\n  2 octet -> sequence number (Network Byte Order)\n  4 octet -> response data size (Network Byte Order)\n\n  The ARR Data:\n\n  n octets -> request/response data\n                        : 'AB..ZAB..ZAB..' \n\n  For software version request/response the \n   protocol version octet will contain the version\n   number of the responder.  Thus the sequence \n   number, etc will not be included.\n\n  For snaLU0EchoAppl and snaLU2EchoAppl all character \n   fields will be in EBCDIC.\n\n  The response data should be appended to the \n   origin request data.  This allows data  \n   verification to check the data that flows in \n   both directions.  If the response data size is\n   smaller than the request data size the original\n   request data will be truncated.  \n\n  An example would be:\n    Request:        /       Response:\n    'WxYz'          /       'WxYz'\n    0x01            /       0x01\n    0x02            /       0x03\n    0x0001          /       0x0001\n    0x00000008      /       0x00000008\n    'ABCDEF'        /       'ABCDEFGH'\n\n  NOTE: We requested 8 bytes in the response and \n        the response had 8 bytes.  The size of the\n        request data has no correlation to the\n        size of the response data.\n\nNOTE:  For native RTT request/response (i.e. \n       ipIcmpecho) operations both the 'Header' \n       and 'Data' will be included.  Only the \n       'sequence number' in the Header will be \n       valid.\n\nNOTE:  For non-connection oriented protocol the \n       initial RTT request/response operation will\n       be preceded with an RTT request/response \n       operation to the target address to force \n       path exploration and to prove \n       connectivity.  The History collection table\n       will contain these responses, but the \n       Statistics capture table will omit them to\n       prevent skewed results.")
ciscoRttMonObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1))
rttMonAppl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1))
rttMonApplVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplVersion.setDescription("Round Trip Time monitoring application version\nstring.\n\nThe format will be:\n\n'Version.Release.Patch-Level: Textual-Description'\n\nFor example:  '1.0.0: Initial RTT Application'")
rttMonApplMaxPacketDataSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly").setUnits("octets")
if mibBuilder.loadTexts: rttMonApplMaxPacketDataSize.setDescription("The maximum size of the data portion an echo\npacket supported by this RTT application.  This is\nthe maximum value that can be specified by\n(rttMonEchoAdminPktDataRequestSize + ARR Header)\nor \n(rttMonEchoAdminPktDataResponseSize + ARR Header)\nin the rttMonCtrlAdminTable.\n\nThis object is undefined for conceptual RTT \ncontrol rows when the RttMonRttType object is set\nto 'fileIO' or 'script'.")
rttMonApplTimeOfLastSet = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplTimeOfLastSet.setDescription("The last time at which a set operation occurred\non any of the objects in this MIB.  The managing \napplication can inspect this value in order to \ndetermine whether changes have been made without \nretrieving the entire Administration portion of\nthis MIB.\n\nThis object applies to all settable objects in this\nMIB, including the 'Reset' objects that could clear\nsaved history/statistics.")
rttMonApplNumCtrlAdminEntry = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplNumCtrlAdminEntry.setDescription("This object defines the maximum number of entries\nthat can be added to the rttMonCtrlAdminTable. It\nis calculated at the system init time. The value\nis impacted when rttMonApplFreeMemLowWaterMark is changed.")
rttMonApplReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 5), RttReset()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplReset.setDescription("When set to 'reset' the entire RTT application\ngoes through a reset sequence, making a best \neffort to revert to its startup condition.  Any \nand all rows in the Overall Control Group will be\nimmediately deleted, together with any associated\nrows in the Statistics Collection Group, and \nHistory Collection Group.  All open connections \nwill also be closed.  Finally the \nrttMonApplPreConfigedTable will reset (see \nrttMonApplPreConfigedReset).")
rttMonApplPreConfigedReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 6), RttReset()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplPreConfigedReset.setDescription("When set to 'reset' the RTT application will\nreset the Application Preconfigured MIB section.\n\nThis will force the RTT application to delete all\nentries in the rttMonApplPreConfigedTable and then\nto repopulate the table with the current configuration.\n\nThis provides a mechanism to load and unload user\nscripts and file paths.")
rttMonApplSupportedRttTypesTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7))
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesTable.setDescription("A table of which contains the supported Rtt\nMonitor Types.\n\nSee the RttMonRttType textual convention for\nthe definition of each type.")
rttMonApplSupportedRttTypesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplSupportedRttTypes"))
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesEntry.setDescription("A list that presents the valid Rtt Monitor\nTypes.")
rttMonApplSupportedRttTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1, 1), RttMonRttType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonApplSupportedRttTypes.setDescription("This object indexes the supported\n'RttMonRttType' types.")
rttMonApplSupportedRttTypesValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplSupportedRttTypesValid.setDescription("This object defines the supported\n'RttMonRttType' types.")
rttMonApplSupportedProtocolsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8))
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsTable.setDescription("A table of which contains the supported Rtt\nMonitor Protocols.\n\nSee the RttMonProtocol textual convention \nfor the definition of each protocol.")
rttMonApplSupportedProtocolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplSupportedProtocols"))
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsEntry.setDescription("A list that presents the valid Rtt Monitor\nProtocols.")
rttMonApplSupportedProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1, 1), RttMonProtocol()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonApplSupportedProtocols.setDescription("This object indexes the supported\n'RttMonProtocol' protocols.")
rttMonApplSupportedProtocolsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 8, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplSupportedProtocolsValid.setDescription("This object defines the supported\n'RttMonProtocol' protocols.")
rttMonApplPreConfigedTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9))
if mibBuilder.loadTexts: rttMonApplPreConfigedTable.setDescription("A table of which contains the previously\nconfigured Script Names and File IO targets.\n\nThese Script Names and File IO targets are installed\nvia a different mechanism than this application, and\nare specific to each platform.")
rttMonApplPreConfigedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplPreConfigedType"), (0, "CISCO-RTTMON-MIB", "rttMonApplPreConfigedName"))
if mibBuilder.loadTexts: rttMonApplPreConfigedEntry.setDescription("A list of objects that describe the previously\nconfigured Script Names and File IO targets.")
rttMonApplPreConfigedType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("filePath", 1), ("scriptName", 2), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonApplPreConfigedType.setDescription("This is the type of value being stored in the\nrttMonApplPreConfigedName object.")
rttMonApplPreConfigedName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 3), DisplayString()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonApplPreConfigedName.setDescription("This is either one of the following depending on the\nvalue of the rttMonApplPreConfigedType object:\n\n - The file path to a server.  One of these file paths \n   must be used when defining an entry in the \n   rttMonFileIOAdminTable table with 'fileIO' as the \n   value of the rttMonCtrlAdminRttType object.\n\n - The script name to be used when generating RTT \n   operations.  One of these script names must be used \n   when defining an entry in the rttMonScriptAdminTable \n   table with 'script' as the value of the \n   rttMonCtrlAdminRttType object.\n\nNOTE:  For script names, command line parameters \n       can follow these names in the \n       rttMonScriptAdminTable table.")
rttMonApplPreConfigedValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 9, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplPreConfigedValid.setDescription("When this row exists, this value will be 'true'.\nThis object exists only to create a valid row in this \ntable.")
rttMonApplProbeCapacity = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplProbeCapacity.setDescription("This object defines the number of new probes that can be\nconfigured on a router. The number depends on the value \nof rttMonApplFreeMemLowWaterMark, free bytes\navailable on the router and the system configured\nrttMonCtrlAdminEntry number.\nEquation:\nrttMonApplProbeCapacity = \nMIN(((Free_Bytes_on_the_Router - rttMonApplFreeMemLowWaterMark)/\nMemory_required_by_each_probe),\nrttMonApplNumCtrlAdminEntry - \nNum_of_Probes_already_configured))")
rttMonApplFreeMemLowWaterMark = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplFreeMemLowWaterMark.setDescription("This object defines the amount of free memory a router must\nhave in order to configure RTR. If RTR found out that the\nmemory is falling below this mark, it will not allow new\nprobes to be configured.\n\nThis value should not be set higher (or very close to) than \nthe free bytes available on the router.")
rttMonApplLatestSetError = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonApplLatestSetError.setDescription("An error description for the last error message caused\nby set.\n\nCurrently, it includes set error caused due to setting\nrttMonApplFreeMemLowWaterMark greater than the available\nfree memory on the router or not enough memory left to\ncreate new probes.")
rttMonApplResponder = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplResponder.setDescription("Enable or disable RTR responder on the router.")
rttMonApplAuthTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14))
if mibBuilder.loadTexts: rttMonApplAuthTable.setDescription("A table which contains the definitions for key-strings\nthat will be used in authenticating RTR Control Protocol.")
rttMonApplAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonApplAuthIndex"))
if mibBuilder.loadTexts: rttMonApplAuthEntry.setDescription("A list that presents the valid parameters for Authenticating\nRTR Control Protocol.")
rttMonApplAuthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonApplAuthIndex.setDescription("Uniquely identifies a row in the rttMonApplAuthTable.\nThis is a pseudo-random number selected by the management\nstation when creating a row via the rttMonApplAuthStatus \nobject. If the pseudo-random number is already in use, an \n'inconsistentValue' is returned. Currently, only one row \ncan be created.")
rttMonApplAuthKeyChain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyChain.setDescription("A string which represents the key-chain name. If multiple\nkey-strings are specified, then the authenticator will \nalternate between the specified strings.")
rttMonApplAuthKeyString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString1.setDescription("A string which represents a key-string name whose id is 1.")
rttMonApplAuthKeyString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString2.setDescription("A string which represents a key-string name whose id is 2.")
rttMonApplAuthKeyString3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString3.setDescription("A string which represents a key-string name whose id is 3.")
rttMonApplAuthKeyString4 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString4.setDescription("A string which represents a key-string name whose id is 4.")
rttMonApplAuthKeyString5 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthKeyString5.setDescription("A string which represents a key-string name whose id is 5.")
rttMonApplAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 14, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonApplAuthStatus.setDescription("The status of the Authentication row.")
rttMonApplLpdGrpStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonApplLpdGrpStatsReset.setDescription("This object is used to reset certain objects within the\nrttMonLpdGrpStatsTable.  When the object is set to value of\nan active LPD Group identifier the associated objects will be\nreset. The reset objects will be set to a value as specified\nin the object's description.\n\nThe following objects will not be reset.\n- rttMonLpdGrpStatsTargetPE\n- rttMonLpdGrpStatsGroupProbeIndex\n- rttMonLpdGrpStatsGroupIndex\n- rttMonLpdGrpStatsStartTimeIndex.")
rttMonCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2))
rttMonCtrlAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1))
if mibBuilder.loadTexts: rttMonCtrlAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring definitions.\n\nThe RTT administration control is in multiple tables.  \nThis first table, is used to create a conceptual RTT \ncontrol row.  The following tables contain objects which \nconfigure scheduling, information gathering, and \nnotification/trigger generation.  All of these tables \nwill create the same conceptual RTT control row as this \ntable using this tables' index as their own index. \n\nThis table is limited in size by the agent \nimplementation.  The object rttMonApplNumCtrlAdminEntry\nwill reflect this tables maximum number of entries.")
rttMonCtrlAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonCtrlAdminEntry.setDescription("A base list of objects that define a conceptual RTT\ncontrol row.")
rttMonCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonCtrlAdminIndex.setDescription("Uniquely identifies a row in the rttMonCtrlAdminTable.\nThis is a pseudo-random number, selected by the management \nstation or auto-generated based on  operation started by the \nmanagement station,when creating a row via\n the rttMonCtrlAdminStatus object.  If the pseudo-random \n number is already in use an 'inconsistentValue' return code \n will be returned when\nset operation is attempted.")
rttMonCtrlAdminOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminOwner.setDescription("Identifies the entity that created this table row.")
rttMonCtrlAdminTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminTag.setDescription("A string which is used by a managing application to\nidentify the RTT target.  This string is inserted into trap\nnotifications, but has no other significance to the \nagent.")
rttMonCtrlAdminRttType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 4), RttMonRttType().clone('echo')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminRttType.setDescription("The type of RTT operation to be performed.  This value\nmust be set in the same PDU or before setting any type\nspecific configuration.\n\nNote: The RTT operation 'lspGroup' cannot be created via this\ncontrol row. It will be created automatically by Auto SAA L3\nMPLS VPN when rttMplsVpnMonCtrlLpd is 'true'.")
rttMonCtrlAdminThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminThreshold.setDescription("This object defines an administrative threshold limit.\nIf the RTT operation time exceeds this limit and if the \nconditions specified in rttMonReactAdminThresholdType or \nrttMonHistoryAdminFilter are satisfied, a\nthreshold is generated.")
rttMonCtrlAdminFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminFrequency.setDescription("Specifies the duration between initiating each RTT\noperation. \n\nThis object cannot be set to a value which would be a \nshorter duration than rttMonCtrlAdminTimeout.\n\nWhen the RttMonRttType specifies an operation that is\nsynchronous in nature, it may happen that the next RTT \noperation is blocked by a RTT operation which has not\nyet completed.  In this case, the value of a counter\n(rttMonStatsCollectBusies) in rttMonStatsCaptureTable is\nincremented in lieu of initiating a RTT operation, and \nthe next attempt will occur at the next\nrttMonCtrlAdminFrequency expiration. \n\nNOTE:  When the rttMonCtrlAdminRttType object is defined \n       to be 'pathEcho', setting this value to a small\n       value for your network size may cause an operation\n       attempt (or multiple attempts) to be started \n       before the previous operation has finished.  In \n       this situation the rttMonStatsCollectBusies object\n       will be incremented in lieu of initiating a new \n       RTT operation, and the next attempt will occur at\n       the next rttMonCtrlAdminFrequency expiration.\n\nWhen the rttMonCtrlAdminRttType object is defined\nto be 'pathEcho', the suggested value for this object \nis greater than rttMonCtrlAdminTimeout times the \nmaximum number of expected hops to the target.\n\nNOTE:  When the rttMonCtrlAdminRttType object is defined \n       to be 'dhcp', the minimum allowed value for this\n       object is 10 seconds.  This restriction is due to\n       protocol limitations described in RFC 2131.")
rttMonCtrlAdminTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminTimeout.setDescription("Specifies the duration to wait for a RTT operation\ncompletion.  The value of this object cannot be set to \na value which would specify a duration exceeding \nrttMonCtrlAdminFrequency.\n\nFor connection oriented protocols, this may cause the\nconnection to be closed by the probe.  Once closed, it\nwill be assumed that the connection reestablishment\nwill be performed.  To prevent unwanted closure of\nconnections, be sure to set this value to a realistic\nconnection timeout.")
rttMonCtrlAdminVerifyData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminVerifyData.setDescription("When set to true, the resulting data in each RTT\noperation is compared with the expected data.  This\nincludes checking header information (if possible) and\nexact packet size.  Any mismatch will be recorded in the\nrttMonStatsCollectVerifyErrors object.\n\nSome RttMonRttTypes may not support this option.  When\na type does not support this option, the agent will \ntransition this object to false.  It is the management\napplications responsibility to check for this \ntransition.")
rttMonCtrlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminStatus.setDescription("The status of the conceptual RTT control row.\n\nIn order for this object to become active, the following \nrow objects must be defined:  \n - rttMonCtrlAdminRttType\nAdditionally:\n - for echo, pathEcho based on 'ipIcmpEcho' and dlsw probes\n    rttMonEchoAdminProtocol and \n    rttMonEchoAdminTargetAddress;\n - for echo, pathEcho based on 'mplsLspPingAppl'\n    rttMonEchoAdminProtocol, rttMonEchoAdminTargetAddress \n    and rttMonEchoAdminLSPFECType\n - for udpEcho, tcpConnect and jitter probes\n    rttMonEchoAdminTargetAddress and\n    rttMonEchoAdminTargetPort\n - for http and ftp probe\n    rttMonEchoAdminURL \n - for dns probe\n    rttMonEchoAdminTargetAddressString \n    rttMonEchoAdminNameServer \n - dhcp probe doesn't require any additional objects\n\nAll other objects can assume default values. The \nconceptual Rtt control row will be placed into a \n'pending' state (via the rttMonCtrlOperState object)\nif rttMonScheduleAdminRttStartTime is not specified.\n\nMost conceptual Rtt control row objects cannot be \nmodified once this conceptual Rtt control row has been \ncreated.  The objects that can change are the following:\n\n - Objects in the rttMonReactAdminTable can be modified\n   as needed without setting this object to \n   'notInService'.\n - Objects in the rttMonScheduleAdminTable can be \n   modified only when this object has the value of\n   'notInService'.\n - The rttMonCtrlOperState can be modified to control\n   the state of the probe.\n\nOnce this object is in 'active' status, it cannot be \nset to 'notInService' while the rttMonCtrlOperState\nis in 'active' state.  Thus the rttMonCtrlOperState \nobject must be transitioned first. \n\nThis object can be set to 'destroy' from any value\nat any time.")
rttMonCtrlAdminNvgen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonCtrlAdminNvgen.setDescription("When set to true, this entry will be shown in\n'show running' command and can be saved into\nNon-volatile memory.")
rttMonCtrlAdminGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 1, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlAdminGroupName.setDescription("If the operation is created through auto measure group\ncreation, then this string will specify the group name\nto which this operation is associated.")
rttMonEchoAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2))
if mibBuilder.loadTexts: rttMonEchoAdminTable.setDescription("A table that contains Round Trip Time (RTT) specific\ndefinitions.\n\nThis table is controlled via the \nrttMonCtrlAdminTable.  Entries in this table are\ncreated via the rttMonCtrlAdminStatus object.")
rttMonEchoAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonEchoAdminEntry.setDescription("A list of objects that define specific configuration for\nRttMonRttType conceptual Rtt control rows.")
rttMonEchoAdminProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 1), RttMonProtocol().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProtocol.setDescription("Specifies the protocol to be used to perform the RTT\noperation. The following list defines what protocol \nshould be used for each probe type:\n\necho, pathEcho   - ipIcmpEcho / mplsLspPingAppl\nudpEcho          - ipUdpEchoAppl\ntcpConnect       - ipTcpConn\nhttp             - httpAppl\njitter           - jitterAppl\ndlsw             - dlswAppl\ndhcp             - dhcpAppl\nftp              - ftpAppl\nmplsLspPing      - mplsLspPingAppl\nvoip             - voipAppl\nvideo            - videoAppl\n\nWhen this protocol does not support the type, a 'badValue'\nerror will be returned.")
rttMonEchoAdminTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 2), RttMonTargetAddress().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddress.setDescription("A string which specifies the address of the target.")
rttMonEchoAdminPktDataRequestSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPktDataRequestSize.setDescription("This object represents the number of octets to be\nplaced into the ARR Data portion of the request \nmessage, when using SNA protocols.\n\nFor non-ARR protocols' RTT request/responses, \nthis value represents the native payload size.\n\nREMEMBER:  The ARR Header overhead is not included \n           in this value.\n\nFor echo probes the total packet size = (IP header(20) + \nICMP header(8) + 8 (internal timestamps) + request size).\n\nFor echo and pathEcho default request size is 28.\nFor udp probe, default request size is 16 and for jitter \nprobe it is 32. For dlsw probes default request size is 0.\n\nThe minimum request size for echo and pathEcho is 28 bytes,\nfor udp it is 4 and for jitter it is 16.\nFor udp and jitter probes the maximum request size is 1500.\n\nFor ethernetPing the default request size is 66.\nFor ethernetJitter the default request size is 51.")
rttMonEchoAdminPktDataResponseSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPktDataResponseSize.setDescription("This object represents the number of octets to be\nplaced into the ARR Data portion of the response message.\nThis value is passed to the RTT Echo Server via a\nfield in the ARR Header.\n\nFor non-ARR RTT request/response (i.e. ipIcmpecho)\nthis value will be set by the agent to match the\nsize of rttMonEchoAdminPktDataRequestSize, when\nnative payloads are supported.\n\nREMEMBER:  The ARR Header overhead is not included \n           in this value.\n\nThis object is only supported by SNA protocols.")
rttMonEchoAdminTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetPort.setDescription("This object represents the target's port number. This\nobject is applicable to udpEcho, tcpConnect and jitter probes.")
rttMonEchoAdminSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 6), RttMonTargetAddress().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourceAddress.setDescription("A string which specifies the IP address of the source.\nThis object is applicable to all probes except dns, dlsw \nand sna.")
rttMonEchoAdminSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourcePort.setDescription("This object represents the source's port number. If this\nobject is not specified, the application will get a \nport allocated by the system. This object is applicable \nto all probes except dns, dlsw and sna.")
rttMonEchoAdminControlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlEnable.setDescription("If this object is enabled, then the RTR application\nwill send control messages to a responder, residing on the \ntarget router to respond to the data request packets being \nsent by the source router. This object is not applicable to \necho, pathEcho, dns and http probes.")
rttMonEchoAdminTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTOS.setDescription("This object represents the type of service octet in an\nIP header. This object is not applicable to dhcp, dns, \nethernetPing and ethernetJitter.")
rttMonEchoAdminLSREnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminLSREnable.setDescription("If this object is enabled then it means that the application\ncalculates response time for a specific path, defined in\nrttMonEchoPathAdminEntry. This object is applicable to echo \nprobe only.")
rttMonEchoAdminTargetAddressString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 11), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetAddressString.setDescription("A string which specifies the address of the target. This string\ncan be in IP address format or a hostname. This object\nis applicable to dns probe only.")
rttMonEchoAdminNameServer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 12), RttMonTargetAddress().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminNameServer.setDescription("A string which specifies the ip address of the name-server.\nThis object is applicable to dns probe only.")
rttMonEchoAdminOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 13), RttMonOperation()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOperation.setDescription("A code that represents the specific type of RTT operation.\nThis object is applicable to http and ftp probe only.")
rttMonEchoAdminHTTPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 10)).clone('1.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminHTTPVersion.setDescription("A string which specifies the version number of the HTTP\nServer.  The syntax for the version string is \n<major number>.<minor number> An example would be 1.0, \n1.1 etc.,.  This object is applicable to http probe only.")
rttMonEchoAdminURL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 15), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminURL.setDescription("A string which represents the URL to which a HTTP probe should\ncommunicate with. This object is applicable to http probe only.")
rttMonEchoAdminCache = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCache.setDescription("If this object is false then it means that HTTP request should\nnot download cached pages. This means that the request should \nbe forwarded to the origin server. This object is applicable\nto http probe only.")
rttMonEchoAdminInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminInterval.setDescription("This value represents the inter-packet delay between packets\nand is in milliseconds. This value is currently used for \nJitter probe. This object is applicable to jitter probe only.")
rttMonEchoAdminNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 18), Integer32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminNumPackets.setDescription("This value represents the number of packets that need to be\ntransmitted. This value is currently used for Jitter probe. \nThis object is applicable to jitter probe only.")
rttMonEchoAdminProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 19), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProxy.setDescription("This string represents the proxy server information.\nThis object is applicable to http probe only.")
rttMonEchoAdminString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 20), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString1.setDescription("This string stores the content of HTTP raw request.\nIf the request cannot fit into String1 then it should \nbe split and put in Strings 1 through 5.\n\nThis string stores the content of the DHCP raw option\ndata.  The raw DHCP option data must be in HEX.\nIf an odd number of characters are specified, a 0\nwill be appended to the end of the string.  Only\nDHCP option 82 (decimal) is allowed.\nHere is an example of a valid string:\n5208010610005A6F1234\nOnly rttMonEchoAdminString1 is used for dhcp, Strings\n1 through 5 are not used.\n\nThis object is applicable to http and dhcp probe \ntypes only.")
rttMonEchoAdminString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 21), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString2.setDescription("This string stores the content of HTTP raw request.\nrttMonEchoAdminString1-5 are concatenated to \nform the HTTP raw request used in the RTT operation.\nThis object is applicable to http probe only.")
rttMonEchoAdminString3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 22), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString3.setDescription("This string stores the content of HTTP raw request.\nrttMonEchoAdminString1-5 are concatenated to \nform the HTTP raw request used in the RTT operation.\nThis object is applicable to http probe only.")
rttMonEchoAdminString4 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 23), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString4.setDescription("This string stores the content of HTTP raw request.\nrttMonEchoAdminString1-5 are concatenated to \nform the HTTP raw request used in the RTT operation.\nThis object is applicable to http probe only.")
rttMonEchoAdminString5 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 24), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminString5.setDescription("This string stores the content of HTTP raw request.\nrttMonEchoAdminString1-5 are concatenated to \nform the HTTP raw request used in the RTT operation.\nThis object is applicable to http probe only.")
rttMonEchoAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 25), RttMonOperation().clone('ftpPassive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminMode.setDescription("A code that represents the specific type of RTT operation.\nThis object is applicable to ftp probe only.")
rttMonEchoAdminVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminVrfName.setDescription("This field is used to specify the VPN name in\nwhich the RTT operation will be used. For regular RTT\noperation this field should not be configured. The agent \nwill use this field to identify the VPN routing Table for\nthis operation.")
rttMonEchoAdminCodecType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 27), RttMonCodecType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecType.setDescription("Specifies the codec type to be used with jitter probe. This is\napplicable only for the jitter probe.\n\nIf codec-type is configured the following parameters cannot be \nconfigured.\nrttMonEchoAdminPktDataRequestSize\nrttMonEchoAdminInterval\nrttMonEchoAdminNumPackets")
rttMonEchoAdminCodecInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecInterval.setDescription("This field represents the inter-packet delay between\npackets and is in milliseconds. This object is applicable\nonly to jitter probe which uses codec type.")
rttMonEchoAdminCodecPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecPayload.setDescription("This object represents the number of octets that needs to be\nplaced into the Data portion of the message. This value is\nused only for jitter probe which uses codec type.")
rttMonEchoAdminCodecNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCodecNumPackets.setDescription("This value represents the number of packets that need to be\ntransmitted. This value is used only for jitter probe which\nuses codec type.")
rttMonEchoAdminICPIFAdvFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminICPIFAdvFactor.setDescription("The advantage factor is dependant on the type of access and\nhow the service is to be used.\nConventional Wire-line     0\nMobility within Building    5\nMobility within geographic area  10\nAccess to hard-to-reach location   20\n\nThis will be used while calculating the ICPIF values\nThis valid only for Jitter while calculating the ICPIF value")
rttMonEchoAdminLSPFECType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 32), Integer().subtype(subtypeSpec=SingleValueConstraint(1,)).subtype(namedValues=NamedValues(("ldpIpv4Prefix", 1), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPFECType.setDescription("The type of the target FEC for the RTT 'echo' and 'pathEcho'\noperations based on 'mplsLspPingAppl' RttMonProtocol.\n\nldpIpv4Prefix   - LDP IPv4 prefix.")
rttMonEchoAdminLSPSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 33), RttMonTargetAddress().clone('7F 00 00 01')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPSelector.setDescription("A string which specifies a valid 127/8 address. This address\nis of the form 127.x.y.z.\nThis address is not used to route the MPLS echo packet to the\ndestination but is used for load balancing in cases where the\nIP payload's destination address is used for load balancing.")
rttMonEchoAdminLSPReplyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 34), RttMonLSPPingReplyMode().clone('replyIpv4Udp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyMode.setDescription("This object specifies the reply mode for the LSP Echo\nrequests.")
rttMonEchoAdminLSPTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPTTL.setDescription("This object represents the TTL setting for MPLS echo request\npackets. For ping operation this represents the TTL value to\nbe set in the echo request packet. For trace operation it\nrepresent the maximum ttl value that can be set in the echo\nrequest packets starting with TTL=1.\n\nFor 'echo' based on mplsLspPingAppl the default TTL will be\nset to 255, and for 'pathEcho' based on mplsLspPingAppl the\ndefault will be set to 30.\n\nNote: This object cannot be set to the value of 0. The\ndefault value of 0 signifies the default TTL values to be\nused for 'echo' and 'pathEcho' based on 'mplsLspPingAppl'.")
rttMonEchoAdminLSPExp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPExp.setDescription("This object represents the EXP value that needs to be\nput as precedence bit in the MPLS echo request IP header.")
rttMonEchoAdminPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 37), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("milliseconds", 1), ("microseconds", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminPrecision.setDescription("This object specifies the accuracy of statistics that\nneeds to be calculated\nmilliseconds - The accuracy of stats will be of milliseconds\nmicroseconds - The accuracy of stats will be in microseconds.\nThis value can be set only for jitter operation")
rttMonEchoAdminProbePakPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 38), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("normal", 1), ("high", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminProbePakPriority.setDescription("This object specifies the priority that will be assigned\nto probe packet.  This value can be set only for jitter \noperation")
rttMonEchoAdminOWNTPSyncTolAbs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 39), Integer32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolAbs.setDescription("This object specifies the total clock synchronization error\non source and responder that is considered acceptable for \noneway measurement when NTP is used as clock synchronization \nmechanism.  The total clock synchronization error is sum of\nNTP offsets on source and responder. The value specified is \nmicroseconds. This value can be set only for jitter operation \nwith precision of microsecond.")
rttMonEchoAdminOWNTPSyncTolPct = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolPct.setDescription("This object specifies the total clock synchronization error\non source and responder that is considered acceptable for \noneway measurement when NTP is used as clock synchronization \nmechanism.  The total clock synchronization error is sum of \nNTP offsets on source and responder. The value is expressed \nas the percentage of actual oneway latency that is measured. \nThis value can be set only for jitter operation with precision \nof microsecond.")
rttMonEchoAdminOWNTPSyncTolType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 41), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("percent", 1), ("absolute", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminOWNTPSyncTolType.setDescription("This object specifies whether the value in specified for oneway\nNTP sync tolerance is absolute value or percent value")
rttMonEchoAdminCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 42), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCalledNumber.setDescription("This string stores the called number of post dial delay.\nThis object is applicable to voip post dial delay probe only.\nThe number will be like the one actualy the user could dial.\nIt has the number required by the local country dial plan, plus\nE.164 number. The maximum length is 24 digits. Only digit (0-9)\nis allowed.")
rttMonEchoAdminDetectPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 43), RttMonOperation().clone('voipDTAlertRinging')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminDetectPoint.setDescription("A code that represents the detect point of post dial delay.\nThis object is applicable to SAA post dial delay probe only.")
rttMonEchoAdminGKRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 44), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminGKRegistration.setDescription("A boolean that represents VoIP GK registration delay.\nThis object is applicable to SAA GK registration delay \nprobe only.")
rttMonEchoAdminSourceVoicePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 45), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSourceVoicePort.setDescription("A string which specifies the voice-port on the source gateway.\nThis object is applicable to RTP probe only.")
rttMonEchoAdminCallDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminCallDuration.setDescription("Duration of RTP/Video Probe session.\nThis object is applicable to RTP and Video probe.")
rttMonEchoAdminLSPReplyDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,63),ValueRangeConstraint(255,255),)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPReplyDscp.setDescription("This object specifies the DSCP value to be set in the IP header\nof the LSP echo reply packet.\nThe value of this object will be in range of DiffServ codepoint\nvalues between 0 to 63.\n\nNote: This object cannot be set to value of 255. This default\nvalue specifies that DSCP is not set for this row.")
rttMonEchoAdminLSPNullShim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 48), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPNullShim.setDescription("This object specifies if the explicit-null label is to be added\nto LSP echo requests which are sent while performing RTT\noperation.")
rttMonEchoAdminTargetMPID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 49), CfmMepid()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMPID.setDescription("This object specifies the destination maintenance point ID.\nIt is only applicable to ethernetPing and ethernetJitter \noperation. It will be set to 0 for other types of \noperations.")
rttMonEchoAdminTargetDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 50), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetDomainName.setDescription("This object specifies the name of the domain in which the\ndestination maintenance point lies. It is only applicable to \nethernetPing and ethernetJitter operation.")
rttMonEchoAdminTargetVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 51), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetVLAN.setDescription("This object specifies the ID of the VLAN in which the\ndestination maintenance point lies. It is only applicable to \nethernetPing and ethernetJitter operation. \nIt will be set to 0 for other types of operations.")
rttMonEchoAdminEthernetCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 52), QosLayer2Cos().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEthernetCOS.setDescription("This object specifies the class of service in an Ethernet\npacket header. It is only applicable to ethernetPing and \nethernetJitter operation.")
rttMonEchoAdminLSPVccvID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminLSPVccvID.setDescription("This object specifies MPLS LSP pseudowire VCCV ID\nvalues between 1 to 2147483647.\n\nNote: This object cannot be set to value of 0. This default\nvalue specifies that VCCV is not set for this row.")
rttMonEchoAdminTargetEVC = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 54), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 100)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetEVC.setDescription("This object specifies the Ethernet Virtual Connection in\nwhich the destination maintenance point lies. It is only \napplicable to ethernetPing and ethernetJitter operation. \nIt will be set to NULL for other types of operations.")
rttMonEchoAdminTargetMEPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 55), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMEPPort.setDescription("This object specifies that Port Level CFM testing towards an\nOutward/Down MEP will be used. It is only applicable to \nethernetPing and ethernetJitter operation. \nIt will be set to NULL for other types of operations.")
rttMonEchoAdminVideoTrafficProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 56), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminVideoTrafficProfile.setDescription("A string which represents the profile name to which a video\nprobe should use. This object is applicable to video probe\nonly.")
rttMonEchoAdminDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 57), Dscp().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminDscp.setDescription("This object represents the Differentiated Service Code Point\n(DSCP) QoS marking in the generated synthetic packets.\n\nValue - DiffServ Class\n    0 - BE (default)\n   10 - AF11\n   12 - AF12\n   14 - AF13\n   18 - AF21\n   20 - AF22\n   22 - AF23\n   26 - AF31\n   28 - AF32\n   30 - AF33\n   34 - AF41\n   36 - AF42\n   38 - AF43\n    8 - CS1\n   16 - CS2\n   24 - CS3\n   32 - CS4\n   40 - CS5\n   48 - CS6\n   56 - CS7\n   46 - EF")
rttMonEchoAdminReserveDsp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 58), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("be", 1), ("gs", 2), ("na", 3), )).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminReserveDsp.setDescription("This object represents the video traffic generation source.\n\nbe : best effort using DSP but without reservation\ngs : guaranteed service using DSP with reservation\nna : not applicable for not using DSP")
rttMonEchoAdminInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 59), InterfaceIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminInputInterface.setDescription("This object represents the network input interface on the\nsender router where the synthetic packets are received from the\nemulated endpoint source. This is used for path congruence with\ncorrect feature processing at the sender router.\n\nThe user can get the InterfaceIndex number from ifIndex object\nby looking up in ifTable. In fact, it should be useful to first\nget the entry by the augmented table ifXTable which has ifName\nobject which matches the interface name used on the router or\nswitch equipment console.")
rttMonEchoAdminEmulateSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 60), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourceAddress.setDescription("This object specifies the IP address of the emulated source\nfrom which the synthetic packets would be generated. If this\nobject is not specified, the emulated source IP address will by\ndefault be the same as rttMonEchoAdminSourceAddress. This object\nis applicable to video probes.")
rttMonEchoAdminEmulateSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateSourcePort.setDescription("This object represents the port number of the emulated source\nfrom which the synthetic packets would be generated. If this\nobject is not specified, the emulated source port number will by\ndefault be the same as rttMonEchoAdminSourcePort. This object is\napplicable to video probes.")
rttMonEchoAdminEmulateTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 62), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetAddress.setDescription("This object specifies the IP address of the emulated target by\nwhich the synthetic packets would be received. If this object is\nnot specified, the emulated target IP address will by default be\nthe same as rttMonEchoAdminTargetAddress. This object is\napplicable to video probes.")
rttMonEchoAdminEmulateTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEmulateTargetPort.setDescription("This object represents the port number of the emulated target\nby which the synthetic packets would be received. If this object\nis not specified, the emulated target port number will by\ndefault be the same as rttMonEchoAdminTargetPort. This object is\napplicable to video probes.")
rttMonEchoAdminTargetMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 64), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminTargetMacAddress.setDescription("This object indicates the MAC address of the target device.\nThis object is only applicable for Y.1731 operations. \nrttMonEchoAdminTargetMacAddress and rttMonEchoAdminTargetMPID\nmay not be used in conjunction.")
rttMonEchoAdminSourceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 65), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminSourceMacAddress.setDescription("This object indicates the MAC address of the source device.\nThis object is only applicable for Y.1731 operations. \nrttMonEchoAdminSourceMacAddress and rttMonEchoAdminSourceMPID\nmay not be used in conjunction.")
rttMonEchoAdminSourceMPID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 66), CfmMepid()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminSourceMPID.setDescription("This object indicates the source maintenance point ID.  It is\nonly applicable to Y.1731 operation.  It will be set to zero for\nother types of opearations.  rttMonEchoAdminSourceMPID and\nrttMonEchoAdminSourceMacAddress may not be used in conjunction.")
rttMonEchoAdminEndPointListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 67), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminEndPointListName.setDescription("This object specifies the name of endpoint list which a probe\nuses to generate operations.")
rttMonEchoAdminSSM = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 68), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminSSM.setDescription("This object specifies if Source Specific Multicast is to be\nadded. This object is applicable to multicast probe only.")
rttMonEchoAdminControlRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 69), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlRetry.setDescription("This object specifies the maximum number of retries for control message.")
rttMonEchoAdminControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminControlTimeout.setDescription("This object specifies the wait duration before control message\ntimeout.")
rttMonEchoAdminIgmpTreeInit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 71), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminIgmpTreeInit.setDescription("This object specifies number of packets to be sent for\nmulticast tree setup. This object is applicable to multicast\nprobe only.")
rttMonEchoAdminEnableBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 72), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminEnableBurst.setDescription("This object indicates that packets will be sent in burst.")
rttMonEchoAdminAggBurstCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 73), Integer32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminAggBurstCycles.setDescription("This object indicates the number of burst cycles to be sent\nduring the aggregate interval. This value is currently used\nfor Y1731 SLM(Synthetic Loss Measurment) probe.\nThis object is applicable to Y1731 SLM probe only.")
rttMonEchoAdminLossRatioNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 74), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminLossRatioNumFrames.setDescription("This object indicates the number of frames over which to\ncalculate the frame loss ratio. This object is applicable \nto Y1731 SLM probe only.")
rttMonEchoAdminAvailNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 75), Integer32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonEchoAdminAvailNumFrames.setDescription("This object indicates the number of frames over which to\ncalculate the availability. This object is applicable to\nY1731 SLM probe only.")
rttMonEchoAdminTstampOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 2, 1, 76), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoAdminTstampOptimization.setDescription("This object specifies whether timestamp optimization is\nenabled.\n\nWhen the value is 'true' then timestamp optimization is\nenabled.  The probe will utilize lower layer (Hardware/Packet\nProcessor) timestamping values to improve accuracy of\nstatistics.\n\nThis value can be set only for udp jitter operation with\nprecision of microsecond.")
rttMonFileIOAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3))
if mibBuilder.loadTexts: rttMonFileIOAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring 'fileIO'\nspecific definitions.\n\nWhen the RttMonRttType is not 'fileIO' this table is\nnot valid.\n\nThis table is controlled via the \nrttMonCtrlAdminTable.  Entries in this table are\ncreated via the rttMonCtrlAdminStatus object.")
rttMonFileIOAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonFileIOAdminEntry.setDescription("A list of objects that define specific configuration for\n'fileIO' RttMonRttType conceptual Rtt control rows.")
rttMonFileIOAdminFilePath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 1), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminFilePath.setDescription("The fully qualified file path that will be the target\nof the RTT operation.\n\nThis value must match one of the rttMonApplPreConfigedName\nentries.")
rttMonFileIOAdminSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,3,2,4,)).subtype(namedValues=NamedValues(("n256", 1), ("n1k", 2), ("n64k", 3), ("n128k", 4), ("n256k", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminSize.setDescription("The size of the file to write/read from the File\nServer.")
rttMonFileIOAdminAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 3, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("write", 1), ("read", 2), ("writeRead", 3), )).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonFileIOAdminAction.setDescription("The File I/O action to be performed.")
rttMonScriptAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4))
if mibBuilder.loadTexts: rttMonScriptAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring 'script'\nspecific definitions.\n\nWhen the RttMonRttType is not 'script' this table is\nnot valid.\n\nThis table is controlled via the\nrttMonCtrlAdminTable.  Entries in this table are\ncreated via the rttMonCtrlAdminStatus object.")
rttMonScriptAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonScriptAdminEntry.setDescription("A list of objects that define specific configuration for\n'script' RttMonRttType conceptual Rtt control rows.")
rttMonScriptAdminName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1, 1), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScriptAdminName.setDescription("This will be the Name of the Script that will be used to\ngenerate RTT operations.  \n\nThis object must match one of the \nrttMonApplPreConfigedName entries.")
rttMonScriptAdminCmdLineParams = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 4, 1, 2), DisplayString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScriptAdminCmdLineParams.setDescription("This will be the actual command line parameters\npassed to the rttMonScriptAdminName when being\nexecuted.")
rttMonScheduleAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5))
if mibBuilder.loadTexts: rttMonScheduleAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring scheduling\nspecific definitions.\n\nThis table is controlled via the\nrttMonCtrlAdminTable.  Entries in this table are\ncreated via the rttMonCtrlAdminStatus object.")
rttMonScheduleAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1))
if mibBuilder.loadTexts: rttMonScheduleAdminEntry.setDescription("A list of objects that define specific configuration for\nthe scheduling of RTT operations.")
rttMonScheduleAdminRttLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttLife.setDescription("This object value will be placed into the\nrttMonCtrlOperRttLife object when the rttMonCtrlOperState\nobject transitions to 'active' or 'pending'.\n\nThe value 2147483647 has a special meaning.  When\nthis object is set to 2147483647, the \nrttMonCtrlOperRttLife object will not decrement.  \nAnd thus the life time will never end.")
rttMonScheduleAdminRttStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 2), TimeTicks().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttStartTime.setDescription("This is the time when this conceptional row will\nactivate.  \n\nThis is the value of MIB-II's sysUpTime in the future.\nWhen sysUpTime equals this value this object will \ncause the activation of a conceptual Rtt row.\n\nWhen an agent has the capability to determine date and \ntime, the agent should store this object as DateAndTime.\nThis allows the agent to completely reset (restart) and\nstill be able to start conceptual Rtt rows at the \nintended time.  If the agent cannot keep date and time\nand the agent resets, all entries should take on one of\nthe special value defined below.\n\nThe first special value allows this conceptual Rtt \ncontrol row to immediately transition the \nrttMonCtrlOperState object into 'active' state when the\nrttMonCtrlAdminStatus  object transitions to active.\nThis special value is defined to be a value of this\nobject that, when initially set, is 1.\n\nThe second special value allows this conceptual Rtt \ncontrol row to immediately transition the \nrttMonCtrlOperState object into 'pending' state when \nthe rttMonCtrlAdminStatus object transitions to active.  \nAlso, when the rttMonCtrlOperRttLife counts down to zero \n(and not when set to zero), this special value causes \nthis conceptual Rtt control row to  retransition the \nrttMonCtrlOperState object into 'pending' state.  This \nspecial value is defined to be a value of this object \nthat, when initially set, is smaller than the current\nsysUpTime. (With the exception of one, as defined in\nthe previous paragraph)")
rttMonScheduleAdminConceptRowAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(3600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeout.setDescription("The amount of time this conceptual Rtt control row will\nexist when not in an 'active' rttMonCtrlOperState.\n\nWhen this conceptual Rtt control row enters an 'active' \nstate, this timer will be reset and suspended.  When \nthis conceptual RTT control row enters a state other \nthan 'active', the timer will be restarted.\n\nNOTE:  When a conceptual Rtt control row ages out, the \n       agent needs to remove the associated entries in \n       the rttMonReactTriggerAdminTable and \n       rttMonReactTriggerOperTable.\n\nWhen this value is set to zero, this entry will\nnever be aged out.\nrttMonScheduleAdminConceptRowAgeout object is superseded by\nrttMonScheduleAdminConceptRowAgeoutV2.")
rttMonScheduleAdminRttRecurring = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminRttRecurring.setDescription("When set to true, this entry will be scheduled to\nrun automatically for the specified duration equal\nto the life configured, at the same time daily.\n\nThis value cannot be set to true \n(a) if rttMonScheduleAdminRttLife object has value greater or\n   equal to 86400 seconds.\n(b) if sum of values of rttMonScheduleAdminRttLife and\n   rttMonScheduleAdminConceptRowAgeout is less or equal to\n   86400 seconds.")
rttMonScheduleAdminConceptRowAgeoutV2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonScheduleAdminConceptRowAgeoutV2.setDescription("The amount of time this conceptual Rtt control row will\nexist when not in an 'active' rttMonCtrlOperState.\n\nWhen this conceptual Rtt control row enters an 'active'\nstate, this timer will be reset and suspended.  When\nthis conceptual RTT control row enters a state other\nthan 'active', the timer will be restarted.\n\nNOTE:  It is the same as rttMonScheduleAdminConceptRowAgeout\n       except DEFVAL is 0 to be consistent with CLI ageout\n       default.\n\nWhen this value is set to zero, this entry will\nnever be aged out.")
rttMonReactAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6))
if mibBuilder.loadTexts: rttMonReactAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring Notification\nand Trigger definitions.\n\nAll Notification/Reactions are applied to all RTT \nEnd-to-End operations.  Thus, they do not apply to hops\nalong a path to the target, when RttMonRttType is \n'pathEcho'.\n\nThe format and content of SNA NMVT's are not defined \nwithin this module.  \n\nIt can be noted, however, that there are Alert NMVT's,\nand traps which are sent when an abnormal\ncondition occurs, i.e. when one of \nrttMonCtrlOperConnectionLostOccurred,\nrttMonCtrlOperTimeoutOccurred or\nrttMonCtrlOperOverThresholdOccurred are changed to true,\nand Resolution NMVT's, and Resolution traps which are \nsent when that condition clears, i.e. when one of\nrttMonCtrlOperConnectionLostOccurred,\nrttMonCtrlOperTimeoutOccurred or\nrttMonCtrlOperOverThresholdOccurred is changed back to \nfalse.\n\nWhen rttMonReactAdminActionType is set to one of the \nfollowing:\n  -  triggerOnly\n  -  trapAndTrigger\n  -  nmvtAndTrigger\n  -  trapNmvtAndTrigger\nThe corresponding rows in the \nrttMonReactTriggerAdminTable defined via the \nrttMonCtrlAdminIndex will become active.\n\nThis table augments the rttMonCtrlAdminTable.\nrttMonReactAdminTable object is superseded by rttMonReactTable.")
rttMonReactAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1))
if mibBuilder.loadTexts: rttMonReactAdminEntry.setDescription("A list of objects that define RTT reaction operations.\nrttMonReactAdminEntry object is superseded by rttMonReactEntry.")
rttMonReactAdminConnectionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminConnectionEnable.setDescription("If true, a reaction is generated when a RTT\noperation to a rttMonEchoAdminTargetAddress\n(echo type) causes \nrttMonCtrlOperConnectionLostOccurred to change its \nvalue.  Thus connections to intermediate hops will \nnot cause this value to change.\nrttMonReactAdminConnectionEnable object is superseded by\nrttMonReactVar.")
rttMonReactAdminTimeoutEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminTimeoutEnable.setDescription("If true, a reaction is generated when a RTT\noperation causes rttMonCtrlOperTimeoutOccurred \nto change its value.  \n\nWhen the RttMonRttType is 'pathEcho' timeouts to \nintermediate hops will not cause \nrttMonCtrlOperTimeoutOccurred to change its value.\nrttMonReactAdminTimeoutEnable object is superseded by\nrttMonReactVar.")
rttMonReactAdminThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(4,5,1,2,3,)).subtype(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdType.setDescription("This object specifies the conditions under which\nrttMonCtrlOperOverThresholdOccurred is changed:\n\nNOTE:  When the RttMonRttType is 'pathEcho' this \n       objects' value and all associated \n       object values are only valid when RTT \n       'echo' operations are to the\n       rttMonEchoAdminTargetAddress object address.  Thus\n       'pathEcho' operations to intermediate\n       hops will not cause this object to change.\n\nnever       - rttMonCtrlOperOverThresholdOccurred is \n               never set\nimmediate   - rttMonCtrlOperOverThresholdOccurred is set \n               to true when an operation completion time \n               exceeds rttMonCtrlAdminThreshold; \n               conversely \n               rttMonCtrlOperOverThresholdOccurred is set \n               to false when an operation completion time \n               falls below \n               rttMonReactAdminThresholdFalling \nconsecutive - rttMonCtrlOperOverThresholdOccurred is set \n               to true when an operation completion time \n               exceeds rttMonCtrlAdminThreshold on \n               rttMonReactAdminThresholdCount consecutive \n               RTT operations; conversely, \n               rttMonCtrlOperOverThresholdOccurred is set \n               to false when an operation completion time\n               falls under the \n               rttMonReactAdminThresholdFalling \n               for the same number of consecutive \n               operations \nxOfy        - rttMonCtrlOperOverThresholdOccurred is set \n               to true when x (as specified by \n               rttMonReactAdminThresholdCount) out of the \n               last y (as specified by \n               rttMonReactAdminThresholdCount2) \n               operation completion time exceeds \n               rttMonCtrlAdminThreshold; \n               conversely, it is set to false when x, \n               out of the last y operation completion\n               time fall below\n               rttMonReactAdminThresholdFalling\n               NOTE: When x > y, the probe will never\n                     generate a reaction.\naverage     - rttMonCtrlOperOverThresholdOccurred is set \n               to true when the running average of the \n               previous rttMonReactAdminThresholdCount \n               operation completion times exceed \n               rttMonCtrlAdminThreshold; conversely, it \n               is set to false when the running average \n               falls below the \n               rttMonReactAdminThresholdFalling\n\nIf this value is changed by a management station, \nrttMonCtrlOperOverThresholdOccurred is set to false, but \nno reaction is generated if the prior value of \nrttMonCtrlOperOverThresholdOccurred was true.\nrttMonReactAdminThresholdType object is superseded by\nrttMonReactThresholdType.")
rttMonReactAdminThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdFalling.setDescription("This object defines a threshold limit. If the RTT\noperation time falls below this limit and if the conditions\nspecified in rttMonReactAdminThresholdType are satisfied, an \nthreshold is generated.\nrttMonReactAdminThresholdFalling object is superseded by\nrttMonReactThresholdFalling.")
rttMonReactAdminThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount.setDescription("This object defines the 'x' value of the xOfy condition\nspecified in rttMonReactAdminThresholdType.\nrttMonReactAdminThresholdCount object is superseded by\nrttMonReactThresholdCountX.")
rttMonReactAdminThresholdCount2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminThresholdCount2.setDescription("This object defines the 'y' value of the xOfy condition\nspecified in rttMonReactAdminThresholdType.\nrttMonReactAdminThresholdCount2 object is superseded by\nrttMonReactThresholdCountyY.")
rttMonReactAdminActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,6,4,7,2,8,5,)).subtype(namedValues=NamedValues(("none", 1), ("trapOnly", 2), ("nmvtOnly", 3), ("triggerOnly", 4), ("trapAndNmvt", 5), ("trapAndTrigger", 6), ("nmvtAndTrigger", 7), ("trapNmvtAndTrigger", 8), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminActionType.setDescription("Specifies what type(s), if any, of reaction(s) to\ngenerate if an operation violates one of the watched \nconditions:\n\nnone               - no reaction is generated\ntrapOnly           - a trap is generated\nnmvtOnly           - an SNA NMVT is generated\ntriggerOnly        - all trigger actions defined for this \n                      entry are initiated\ntrapAndNmvt        - both a trap and an SNA NMVT are \n                      generated\ntrapAndTrigger     - both a trap and all trigger actions \n                      are initiated \nnmvtAndTrigger     - both a NMVT and all trigger actions \n                      are initiated\ntrapNmvtAndTrigger - a NMVT, trap, and all trigger actions\n                      are initiated\n\nA trigger action is defined via the \nrttMonReactTriggerAdminTable.\nrttMonReactAdminActionType object is superseded by\nrttMonReactActionType.")
rttMonReactAdminVerifyErrorEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 6, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactAdminVerifyErrorEnable.setDescription("If true, a reaction is generated when a RTT\noperation causes rttMonCtrlOperVerifyErrorOccurred \nto change its value.\nrttMonReactAdminVerifyErrorEnable object is superseded by\nrttMonReactVar.")
rttMonStatisticsAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7))
if mibBuilder.loadTexts: rttMonStatisticsAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring statistics\ndefinitions. \n\nThe definitions in this table control what and how many\nentries will be placed into the rttMonStatsCaptureTable.\n\nThe statistics capture table is a rollover table.  When \nthe rttMonStatisticsAdminNumHourGroups index value \nexceeds its value defined in this table, the oldest \ncorresponding group will be deleted and will be replaced \nwith the new group.  All other indices will only fill to \nthere maximum size.\n\nNOTE:  The maximum size of this table is defined to be\n       the product of the rttMonCtrlAdminIndex times\n       rttMonStatisticsAdminNumHourGroups times\n       rttMonStatisticsAdminNumPaths times\n       rttMonStatisticsAdminNumHops times\n       rttMonStatisticsAdminNumDistBuckets. \n\nNOTE WELL:  Each of the 'Num' objects values in this \n            have a special behavior.  When one of the\n            objects is set to a value larger than the\n            Rtt application can support the set will\n            succeed, but the resultant value will\n            be set to the applications maximum value. \n            The setting management station must reread\n            this object to verify the actual value.\n\nThis table augments the rttMonCtrlAdminTable.")
rttMonStatisticsAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1))
if mibBuilder.loadTexts: rttMonStatisticsAdminEntry.setDescription("A list of objects that define RTT statistics\ncapture operations.")
rttMonStatisticsAdminNumHourGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHourGroups.setDescription("The maximum number of groups of paths to record.\nSpecifically this is the number of hourly groups \nto keep before rolling over.  \n\nThe value of one is not advisable because the \ngroup will close and immediately be deleted before\nthe network management station will have the \nopportunity to retrieve the statistics. \n\nThe value used in the rttMonStatsCaptureTable to \nuniquely identify this group is the \nrttMonStatsCaptureStartTimeIndex.\n\nHTTP and Jitter probes store only two hours of data.\n\nWhen this object is set to the value of zero all \nrttMonStatsCaptureTable data capturing will be shut off.")
rttMonStatisticsAdminNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumPaths.setDescription("When RttMonRttType is 'pathEcho' this is the maximum\nnumber of statistics paths to record per hourly group.  \nThis value directly represents the path to a target.  \nFor all other RttMonRttTypes this value will be \nforced to one by the agent.\n\nNOTE: For 'pathEcho' a source to target path will be \n      created to to hold all errors that occur when a \n      specific path or connection has not be found/setup. \n      Thus, it is advised to set this value greater\n      than one.\n\nSince this index does not rollover, only the first\nrttMonStatisticsAdminNumPaths will be kept.")
rttMonStatisticsAdminNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumHops.setDescription("When RttMonRttType is 'pathEcho' this is the maximum\nnumber of statistics hops to record per path group.  \nThis value directly represents the number of hops along \na path to a target, thus we can only support 30 hops.  \nFor all other RttMonRttTypes this value will be \nforced to one by the agent.\n\nSince this index does not rollover, only the first\nrttMonStatisticsAdminNumHops will be kept. This object \nis applicable to pathEcho probes only.")
rttMonStatisticsAdminNumDistBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminNumDistBuckets.setDescription("The maximum number of statistical distribution\nBuckets to accumulate.\n\nSince this index does not rollover, only the first\nrttMonStatisticsAdminNumDistBuckets will be kept.\n\nThe last rttMonStatisticsAdminNumDistBucket will\ncontain all entries from its distribution interval\nstart point to infinity. This object is not applicable \nto http and jitter probes.")
rttMonStatisticsAdminDistInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonStatisticsAdminDistInterval.setDescription("The statistical distribution buckets interval.\n\nDistribution Bucket Example:\n\nrttMonStatisticsAdminNumDistBuckets = 5 buckets\nrttMonStatisticsAdminDistInterval = 10 milliseconds\n\n| Bucket 1 | Bucket 2 | Bucket 3 | Bucket 4 | Bucket 5  |\n|  0-9 ms  | 10-19 ms | 20-29 ms | 30-39 ms | 40-Inf ms |\n\nOdd Example:\n\nrttMonStatisticsAdminNumDistBuckets = 1 buckets\nrttMonStatisticsAdminDistInterval = 10 milliseconds\n\n| Bucket 1  |\n|  0-Inf ms |\n\nThus, this odd example shows that the value of \nrttMonStatisticsAdminDistInterval does not apply when\nrttMonStatisticsAdminNumDistBuckets is one.\nThis object is not applicable to http and jitter probes.")
rttMonHistoryAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8))
if mibBuilder.loadTexts: rttMonHistoryAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring history\ndefinitions.\n\nThe definitions in this table control what and how many\nentries will be placed into the \nrttMonHistoryCollectionTable.\n\nThe history collection table is a rollover table.  When \nthe rttMonHistoryAdminNumLives index value exceeds its \nvalue defined in this table, the oldest corresponding \n'lives' group will be deleted and will be replaced with \nthe new 'lives' group.  All other indices will only fill\nto their maximum size.\n\nNOTE:  The maximum size of this table is defined to be\n       the product of the rttMonCtrlAdminIndex times\n       rttMonHistoryAdminNumLives times\n       rttMonHistoryAdminNumBuckets times\n       rttMonHistoryAdminNumSamples.\n\nNOTE WELL:  Each of the 'Num' objects values in this \n            have a special behavior.  When one of the\n            objects is set to a value larger than the\n            Rtt application can support the set will\n            succeed, but the resultant value will\n            be set to the applications maximum value. \n            The setting management station must reread\n            this object to verify the actual value.\n\nNOTE: this table is not applicable to http and jitter \n      probes")
rttMonHistoryAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1))
if mibBuilder.loadTexts: rttMonHistoryAdminEntry.setDescription("A list of objects that define RTT history collection\noperations.")
rttMonHistoryAdminNumLives = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumLives.setDescription("The maximum number of history lives to record.  A life\nis defined by the countdown (or transition) to zero \nby the rttMonCtrlOperRttLife object.  A new life is\ncreated when the same conceptual RTT control row is\nrestarted via the transition of the \nrttMonCtrlOperRttLife object and its subsequent \ncountdown.\n\nThe value of zero will shut off all \nrttMonHistoryAdminTable data collection.")
rttMonHistoryAdminNumBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumBuckets.setDescription("The maximum number of history buckets to record.  When\nthe RttMonRttType is 'pathEcho'  this value directly \nrepresents a path to a target.  For all other \nRttMonRttTypes this value should be set to the number \nof operations to keep per lifetime.\n\nAfter rttMonHistoryAdminNumBuckets are filled, the \nand the oldest entries are deleted and the most recent\nrttMonHistoryAdminNumBuckets buckets are retained.")
rttMonHistoryAdminNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminNumSamples.setDescription("The maximum number of history samples to record per\nbucket.  When the RttMonRttType is 'pathEcho' this \nvalue directly represents the number of hops along a \npath to a target, thus we can only support 30 hops.\nFor all other RttMonRttTypes this value will be \nforced to one by the agent.")
rttMonHistoryAdminFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 8, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(3,4,1,2,)).subtype(namedValues=NamedValues(("none", 1), ("all", 2), ("overThreshold", 3), ("failures", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonHistoryAdminFilter.setDescription("Defines a filter for adding RTT results to the history\nbuffer:\n\nnone          - no history is recorded\nall           - the results of all completion times \n                 and failed completions are recorded\noverThreshold - the results of completion times\n                 over rttMonCtrlAdminThreshold are \n                 recorded.\nfailures      - the results of failed operations (only) \n                 are recorded.")
rttMonCtrlOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9))
if mibBuilder.loadTexts: rttMonCtrlOperTable.setDescription("A table of which contains the Operational values for the\nprobe, and the conceptual RTT control row. \n\nThis table augments the rttMonCtrlAdminTable.")
rttMonCtrlOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1))
if mibBuilder.loadTexts: rttMonCtrlOperEntry.setDescription("A list of objects that describe the current state\nof probe, and the conceptual RTT control row.")
rttMonCtrlOperModificationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperModificationTime.setDescription("This object is updated whenever an object in\nthe conceptual RTT control row is changed or\nupdated.")
rttMonCtrlOperDiagText = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 51)).clone('')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperDiagText.setDescription("A string which can be used as an aid in tracing problems.\nThe content of this field will depend on the type of \ntarget (rttMonEchoAdminProtocol). \n\nWhen rttMonEchoAdminProtocol is one of snaLU0EchoAppl, or \nsnaLU2EchoAppl this object contains the name of the \nLogical Unit (LU) being used for this RTT session (from\nthe HOST's point of view), once the session has been \nestablished; this can then be used to correlate this \nname to the connection information stored in the \nMainframe Host.\n\nWhen rttMonEchoAdminProtocol is snaLU62EchoAppl, this \nobject contains the Logical Unit (LU) name being used for\nthis RTT session, once the session has been established.  \nThis name can be used by the management application to \ncorrelate this objects value to the connection \ninformation stored at this SNMP Agent via the APPC or \nAPPN mib.\n\nWhen rttMonEchoAdminProtocol is not one of the \npreviously mentioned values, this value will be null.\n\nIt is primarily intended that this object contains \ninformation which has significance to a human operator.")
rttMonCtrlOperResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperResetTime.setDescription("This object is set when the rttMonCtrlOperState is set\nto reset.")
rttMonCtrlOperOctetsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperOctetsInUse.setDescription("This object is the number of octets currently in use\nby this composite conceptual RTT row.  A composite\nconceptual row include the control, statistics, and \nhistory conceptual rows combined.  (All octets that\nare addressed via the rttMonCtrlAdminIndex in this\nmib.)")
rttMonCtrlOperConnectionLostOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperConnectionLostOccurred.setDescription("This object will only change its value when the\nRttMonRttType is 'echo' or 'pathEcho'.\n\nThis object is set to true when the RTT connection fails \nto be established or is lost, and set to false when a \nconnection is reestablished.  When the RttMonRttType\nis 'pathEcho', connection loss applies only to the\nrttMonEchoAdminTargetAddress and not to intermediate\nhops to the Target.\n\nWhen this value changes and \nrttMonReactAdminConnectionEnable is true, a reaction \nwill occur. \n\nIf a trap is sent it is a \nrttMonConnectionChangeNotification.\n\nWhen this value changes and any one of the rttMonReactTable row\nhas rttMonReactVar object value as 'connectionLoss(8)',\na reaction may occur.\n\nIf a trap is sent it is rttMonNotification with rttMonReactVar\nvalue of 'connectionLoss'.")
rttMonCtrlOperTimeoutOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 6), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperTimeoutOccurred.setDescription("This object will change its value for all\nRttMonRttTypes.\n\nThis object is set to true when an operation times out, \nand set to false when an operation completes under \nrttMonCtrlAdminTimeout.  When this value changes, a \nreaction may occur, as defined by \nrttMonReactAdminTimeoutEnable. \n\nWhen the RttMonRttType is 'pathEcho', this timeout\napplies only to the rttMonEchoAdminTargetAddress and\nnot to intermediate hops to the Target.\n\nIf a trap is sent it is a rttMonTimeoutNotification.\n\nWhen this value changes and any one of the rttMonReactTable\nrow has rttMonReactVar object value as 'timeout(7)', a reaction\nmay occur.\n\nIf a trap is sent it is rttMonNotification with rttMonReactVar\nvalue of 'timeout'.")
rttMonCtrlOperOverThresholdOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 7), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperOverThresholdOccurred.setDescription("This object will change its value for all\nRttMonRttTypes.\n\nThis object is changed by operation completion times over\nthreshold, as defined by rttMonReactAdminThresholdType.  \nWhen this value changes, a reaction may occur, as defined \nby rttMonReactAdminThresholdType. \n\nIf a trap is sent it is a rttMonThresholdNotification.\n\nThis object is set to true if the operation completion time\nexceeds the rttMonCtrlAdminThreshold and set to false when an\noperation completes under rttMonCtrlAdminThreshold. When this\nvalue changes, a reaction may occur, as defined by\nrttMonReactThresholdType.\n\nIf a trap is sent it is rttMonNotification with rttMonReactVar\nvalue of 'rtt'.")
rttMonCtrlOperNumRtts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperNumRtts.setDescription("This is the total number of probe operations that have\nbeen attempted.   \n\nThis value is incremented for each start of an RTT \noperation.  Thus when rttMonCtrlAdminRttType is set to \n'pathEcho' this value will be incremented by one and \nnot for very every hop along the path.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.\n\nThis value is not effected by the rollover of a statistics\nhourly group.")
rttMonCtrlOperRttLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperRttLife.setDescription("This object is decremented every second, until it\nreaches zero.  When the value of this object is zero\nRTT operations for this row are suspended.  This \nobject will either reach zero by a countdown or \nit will transition to zero via setting the\nrttMonCtrlOperState.\n\nWhen this object reaches zero the agent needs to \ntransition the rttMonCtrlOperState to 'inactive'.\n\nREMEMBER:  The value 2147483647 has a special \n           meaning.  When this object has the\n           value 2147483647, this object will\n           not decrement.  And thus the life \n           time will never.\n\nWhen the rttMonCtrlOperState object is 'active' and \nthe rttMonReactTriggerOperState object transitions to \n'active' this object will not be updated with the \ncurrent value of rttMonCrtlAdminRttLife object.")
rttMonCtrlOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,7,2,6,3,4,)).subtype(namedValues=NamedValues(("reset", 1), ("orderlyStop", 2), ("immediateStop", 3), ("pending", 4), ("inactive", 5), ("active", 6), ("restart", 7), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rttMonCtrlOperState.setDescription("The RttMonOperStatus object is used to\nmanage the 'state' of the probe that is implementing \nconceptual RTT control row.\n\nThis status object has six defined values:\n\nreset(1)          - reset this entry, transition\n                    to 'pending'\norderlyStop(2)    - shutdown this entry at the end\n                     of the next RTT operation attempt, \n                     transition to 'inactive'\nimmediateStop(3)  - shutdown this entry immediately\n                     (if possible), transition to \n                     'inactive'\npending(4)        - this value is not settable and\n                     this conceptual RTT control row is \n                     waiting for further control either \n                     via the rttMonScheduleAdminTable \n                     or the rttMonReactAdminTable/\n                     rttMonReactTriggerAdminTable;\n                     This object can transition to this\n                     value via two mechanisms, first by\n                     reseting this object, and second\n                     by creating a conceptual Rtt control\n                     row with the \n                     rttMonScheduleAdminRttStartTime\n                     object with the its special value\ninactive(5)       - this value is not settable and\n                     this conceptual RTT control row is \n                     waiting for further control via\n                     the rttMonScheduleAdminTable;\n                     This object can transition to this\n                     value via two mechanisms, first by\n                     setting this object to 'orderlyStop'\n                     or 'immediateStop', second by \n                     the rttMonCtrlOperRttLife object\n                     reaching zero\nactive(6)         - this value is not settable and\n                     this conceptual RTT control row is\n                     currently active\nrestart(7)        - this value is only settable when the\n                     state is active. It clears the data\n                     of this entry and remain on active state.\n\nThe probes action when this object is set to 'reset':\n  -  all rows in rttMonStatsCaptureTable that relate to \n      this conceptual RTT control row are destroyed and \n      the indices are set to 1\n  -  if rttMonStatisticsAdminNumHourGroups is not zero, a \n      single new rttMonStatsCaptureTable row is created\n  -  all rows in rttMonHistoryCaptureTable that relate \n      to this RTT definition are destroyed and the indices\n      are set to 1\n  -  implied history used for timeout or threshold\n      notification (see rttMonReactAdminThresholdType or\n      rttMonReactThresholdType)\n      is purged\n  -  rttMonCtrlOperRttLife is set to \n      rttMonScheduleAdminRttLife\n  -  rttMonCtrlOperNumRtts is set to zero\n  -  rttMonCtrlOperTimeoutOccurred, \n      rttMonCtrlOperOverThresholdOccurred, and \n      rttMonCtrlOperConnectionLostOccurred are set to \n      false; if this causes a change in the value of \n      either of these objects, resolution notifications \n      will not occur\n  -  the next RTT operation is controlled by the objects\n      in the rttMonScheduleAdminTable or the \n      rttMonReactAdminTable/rttMonReactTriggerAdminTable\n  -  if the rttMonReactTriggerOperState is 'active', it \n      will transition to 'pending'\n  -  all rttMonReactTriggerAdminEntries pointing to\n      this conceptual entry with their \n      rttMonReactTriggerOperState object 'active', \n      will transition their OperState to 'pending'\n  -  all open connections must be maintained\n\nThis can be used to synchronize various RTT \ndefinitions, so that the RTT requests occur \nsimultaneously, or as simultaneously as possible.\n\nThe probes action when this object transitions to \n  'inactive' (via setting this object to 'orderlyStop' \n  or 'immediateStop' or by rttMonCtrlOperRttLife \n  reaching zero):\n  -  all statistics and history collection information\n      table entries will be closed and kept\n  -  implied history used for timeout or threshold\n      notification (see rttMonReactAdminThresholdType or\n      rttMonReactThresholdType)\n      is purged\n  -  rttMonCtrlOperTimeoutOccurred, \n      rttMonCtrlOperOverThresholdOccurred, and \n      rttMonCtrlOperConnectionLostOccurred are set to \n      false; if this causes a change in the value of \n      either of these objects, resolution notifications \n      will not occur.\n  -  the next RTT request is controlled by the objects\n      in the rttMonScheduleAdminTable\n  -  if the rttMonReactTriggerOperState is 'active', it \n      will transition to 'pending' (this denotes that\n      the Trigger will be ready the next time this\n      object goes active)\n  -  all rttMonReactTriggerAdminEntries pointing to\n      this conceptual entry with their \n      rttMonReactTriggerOperState object 'active', \n      will transition their OperState to 'pending'\n  -  all open connections are to be closed and cleanup.\n\n             rttMonCtrlOperState\n                    STATE\n          +-------------------------------------------+\n          |      A       |       B      |      C      |\nACTION       |  'pending'   |  'inactive'  |   'active'  |\n+----------------+--------------+--------------+-------------+\n| OperState set  |    noError   |inconsistent- |   noError   |\n|  to 'reset'    |              | Value        |             |\n|                |    -> A      |              |   -> A      |\n+----------------+--------------+--------------+-------------+\n| OperState set  |    noError   |    noError   |   noError   |\n|to 'orderlyStop'|    -> B      |    -> B      |   -> B      |\n|     or to      |              |              |             |\n|'immediateStop' |              |              |             |\n+----------------+--------------+--------------+-------------+\n|  Event causes  |    -> C      |    -> B      |   -> C      |\n| Trigger State  |              |              |   see (3)   |\n| to transition  |              |              |             |\n| to 'active'    |              |              |             |\n+----------------+--------------+--------------+-------------+\n| AdminStatus    |    -> C      |    -> C      |   see (1)   |\n| transitions to |              |              |             |\n| 'active' &     |              |              |             |\n| RttStartTime is|              |              |             |\n| special value  |              |              |             |\n| of one.        |              |              |             |\n+----------------+--------------+--------------+-------------+\n| AdminStatus    |    -> A      |    -> A      |   see (1)   |\n| transitions to |              |              |             |\n| 'active' &     |              |              |             |\n| RttStartTime is|              |              |             |\n| special value  |              |              |             |\n| of less than   |              |              |             |\n| current time,  |              |              |             |\n| excluding one. |              |              |             |\n+----------------+--------------+--------------+-------------+\n| AdminStatus    |    -> A      |    -> B      |   see (2)   |\n| transitions to |              |              |             |\n| 'notInService' |              |              |             |\n+----------------+--------------+--------------+-------------+\n| AdminStatus    |    -> B      |    -> B      |   -> B      |\n| transitions to |              |              |             |\n| 'delete'       |              |              |             |\n+----------------+--------------+--------------+-------------+\n| AdminStatus is |    -> C      |    -> C      |   -> C      |\n| 'active' & the |              |              |   see (3)   |\n| RttStartTime   |              |              |             |\n| arrives        |              |              |             |\n+----------------+--------------+--------------+-------------+\n|   RowAgeout    |    -> B      |    -> B      |   -> B      |\n|    expires     |              |              |             |\n+----------------+--------------+--------------+-------------+\n|  OperRttLife   |    N/A       |    N/A       |   -> B      |\n| counts down to |              |              |             |\n| zero           |              |              |             |\n+----------------+--------------+--------------+-------------+\n\n(1) - rttMonCtrlOperState must have transitioned to 'inactive'\nor 'pending' before the rttMonCtrlAdminStatus can\ntransition to 'active'.  See (2).\n(2) - rttMonCtrlAdminStatus cannot transition to 'notInService'\nunless rttMonCtrlOperState has been previously forced\nto 'inactive' or 'pending'.\n(3) - when this happens the rttMonCtrlOperRttLife will not\nbe updated with the rttMonCtrlAdminRttLife.\n\nNOTE:  In order for all objects in a PDU to be set\n       at the same time, this object can not be\n       part of a multi-bound PDU.")
rttMonCtrlOperVerifyErrorOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 9, 1, 11), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonCtrlOperVerifyErrorOccurred.setDescription("This object is true if rttMonCtrlAdminVerifyData is\nset to true and data corruption occurs.")
rttMonLatestRttOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10))
if mibBuilder.loadTexts: rttMonLatestRttOperTable.setDescription("A table of which contains the status of latest RTT\noperation. \n\nWhen the RttMonRttType is 'pathEcho', operations \nperformed to the hops along the path will be recorded\nin this table.\n\nThis table augments the RTT definition table, \nrttMonCtrlAdminTable.")
rttMonLatestRttOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1))
if mibBuilder.loadTexts: rttMonLatestRttOperEntry.setDescription("A list of objects that record the latest RTT operation.")
rttMonLatestRttOperCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperCompletionTime.setDescription("The completion time of the latest RTT operation\nsuccessfully completed.\n\nThe unit of this object will be microsecond when\nrttMonCtrlAdminRttType is set to 'jitter' and \nrttMonEchoAdminPrecision is set to 'microsecond'.\nOtherwise, the unit of this object will be millisecond.")
rttMonLatestRttOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 2), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperSense.setDescription("A sense code for the completion status of the latest\nRTT operation.")
rttMonLatestRttOperApplSpecificSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperApplSpecificSense.setDescription("An application specific sense code for the\ncompletion status of the latest RTT operation.  This \nobject will only be valid when the \nrttMonLatestRttOperSense object is set to \n'applicationSpecific'.  Otherwise, this object's \nvalue is not valid.")
rttMonLatestRttOperSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperSenseDescription.setDescription("A sense description for the completion status of\nthe latest RTT operation when the \nrttMonLatestRttOperSense object is set to \n'applicationSpecific'.")
rttMonLatestRttOperTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperTime.setDescription("The value of the agent system time at the time of the\nlatest RTT operation.")
rttMonLatestRttOperAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 10, 1, 6), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestRttOperAddress.setDescription("When the RttMonRttType is 'echo', 'pathEcho', 'udpEcho',\n'tcpConnect', 'dns' and 'dlsw' this is a string which specifies \nthe address of the target for this RTT operation.  When the \nRttMonRttType is not one of these types this object will \nbe null.\n\nThis address will be the address of the hop along the\npath to the rttMonEchoAdminTargetAddress address,\nincluding rttMonEchoAdminTargetAddress address, or just\nthe rttMonEchoAdminTargetAddress address, when the\npath information is not collected.  This behavior is\ndefined by the rttMonCtrlAdminRttType object.\n\nThe interpretation of this string depends on the type\nof RTT operation selected, as specified by the\nrttMonEchoAdminProtocol object.\n\nSee rttMonEchoAdminTargetAddress for a complete\ndescription.")
rttMonReactTriggerAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11))
if mibBuilder.loadTexts: rttMonReactTriggerAdminTable.setDescription("A table of which contains the list of conceptual RTT\ncontrol rows that will start to collect data when a \nreaction condition is violated and when \nrttMonReactAdminActionType is set to one of the \nfollowing:\n  -  triggerOnly\n  -  trapAndTrigger\n  -  nmvtAndTrigger\n  -  trapNmvtAndTrigger\nor when a reaction condition is violated and when any of the\nrow in rttMonReactTable has rttMonReactActionType as one of\nthe following:\n  - triggerOnly\n  - trapAndTrigger\n\nThe goal of this table is to define one or more \nadditional conceptual RTT control rows that will become\nactive and start to collect additional history and\nstatistics (depending on the rows configuration values),\nwhen a problem has been detected.\n\nIf the conceptual RTT control row is undefined, and a \ntrigger occurs, no action will take place.  \n\nIf the conceptual RTT control row is scheduled to start \nat a later time, triggering that row will have no effect.\n\nIf the conceptual RTT control row is currently active, \ntriggering that row will have no effect on that row, but \nthe rttMonReactTriggerOperState object will transition to \n'active'.\n\nAn entry in this table can only be triggered when\nit is not currently in a triggered state.  The\nobject rttMonReactTriggerOperState will \nreflect the state of each entry in this table.")
rttMonReactTriggerAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonReactTriggerAdminRttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonReactTriggerAdminEntry.setDescription("A list of objects that will be triggered when\na reaction condition is violated.")
rttMonReactTriggerAdminRttMonCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonReactTriggerAdminRttMonCtrlAdminIndex.setDescription("This object points to a single conceptual Rtt control\nrow.  If this row does not exist and this value is \ntriggered no action will result.\n\nThe conceptual Rtt control row will be triggered for the \nrttMonCtrlOperRttLife length.  If this conceptual Rtt\ncontrol row is already active, rttMonCtrlOperRttLife will\nnot be updated, and its life will continue as previously \ndefined.")
rttMonReactTriggerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 11, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactTriggerAdminStatus.setDescription("This object is used to create Trigger entries.")
rttMonReactTriggerOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12))
if mibBuilder.loadTexts: rttMonReactTriggerOperTable.setDescription("A table of which contains the operational state\nof each entry in the \nrttMonReactTriggerAdminTable.\n\nThis table augments the RTT trigger \ndefinition table, rttMonReactTriggerAdminTable.")
rttMonReactTriggerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12, 1))
if mibBuilder.loadTexts: rttMonReactTriggerOperEntry.setDescription("A list of state objects for the\nrttMonReactTriggerAdminTable.")
rttMonReactTriggerOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 12, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("active", 1), ("pending", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactTriggerOperState.setDescription("This object takes on the value active\nwhen its associated entry in the \nrttMonReactTriggerAdminTable has been\ntriggered.\n\nWhen the associated entry in the\nrttMonReactTriggerAdminTable is not under\na trigger state, this object will be\npending.\n\nWhen this object is in the active state\nthis entry can not be retriggered.")
rttMonEchoPathAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13))
if mibBuilder.loadTexts: rttMonEchoPathAdminTable.setDescription("A table to store the hop addresses in a Loose Source Routing\npath. Response times are computed along the specified path\nusing ping.\n\nThis maximum table size is limited by the size of the \nmaximum number of hop addresses that can fit in an IP header,\nwhich is 8. The object rttMonEchoPathAdminEntry will reflect \nthis tables maximum number of entries.\n\nThis table is coupled with rttMonCtrlAdminStatus.")
rttMonEchoPathAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonEchoPathAdminHopIndex"))
if mibBuilder.loadTexts: rttMonEchoPathAdminEntry.setDescription("A list of objects that define intermediate hop's IP Address.\n\nThis entry can be added only if the rttMonCtrlAdminRttType is\n'echo'. The entry gets deleted when the corresponding RTR entry,\nwhich has an index of rttMonCtrlAdminIndex, is deleted.")
rttMonEchoPathAdminHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonEchoPathAdminHopIndex.setDescription("Uniquely identifies a row in the rttMonEchoPathAdminTable.\nThis number represents the hop address number in a specific \nping path. All the indicies should start from 1 and must be \ncontiguous ie., entries should be \n(say rttMonCtrlAdminIndex = 1) \n1.1, 1.2, 1.3, they cannot be 1.1, 1.2, 1.4")
rttMonEchoPathAdminHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 13, 1, 2), RttMonTargetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonEchoPathAdminHopAddress.setDescription("A string which specifies the address of an intermediate hop's\nIP Address for a RTT 'echo' operation")
rttMonGrpScheduleAdminTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14))
if mibBuilder.loadTexts: rttMonGrpScheduleAdminTable.setDescription("A table of Round Trip Time (RTT) monitoring group scheduling\nspecific definitions.\nThis table is used to create a conceptual group scheduling\ncontrol row. The entries in this control row contain objects\nused to define group schedule configuration parameters.\n\nThe objects of this table will be used to schedule a group of\nprobes identified by the conceptual rows of the\nrttMonCtrlAdminTable.")
rttMonGrpScheduleAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminIndex"))
if mibBuilder.loadTexts: rttMonGrpScheduleAdminEntry.setDescription("A list of objects that define a conceptual group scheduling\ncontrol row.")
rttMonGrpScheduleAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminIndex.setDescription("Uniquely identifies a row in the\nrttMonGrpScheduleAdminTable.\n\nThis is a pseudo-random number selected by the management\nstation when creating a row via the\nrttMonGrpScheduleAdminStatus object. If the pseudo-random\nnumber is already in use an 'inconsistentValue' return code\nwill be returned when set operation is attempted.")
rttMonGrpScheduleAdminProbes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 200)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminProbes.setDescription("A string which holds the different probes which are to be\ngroup scheduled. The probes can be specified in the following\nforms.\n(a) Individual ID's with comma separated as 23,45,34.\n(b) Range form including hyphens with multiple ranges being\n    separated by a comma as 1-10,12-34.\n(c) Mix of the above two forms as 1,2,4-10,12,15,19-25.\n\nAny whitespace in the string is considered an error. Duplicates\nand overlapping ranges as an example 1,2,3,2-10 are considered\nfine. For a single range like 1-20 the upper value (in this\nexample 20) must be greater than lower value (1), otherwise it's\ntreated as an error. The agent will not normalize the list e.g.,\nit will not change 1,2,1-10 or even 1,2,3,4,5,6.. to 1-10.")
rttMonGrpScheduleAdminPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminPeriod.setDescription("Specifies the time duration over which all the probes have to\nbe scheduled.")
rttMonGrpScheduleAdminFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFrequency.setDescription("Specifies the duration between initiating each RTT\noperation for all the probes specified in the group.\n\nThe value of this object is only effective when both\nrttMonGrpScheduleAdminFreqMax and rttMonGrpScheduleAdminFreqMin \nhave zero values.")
rttMonGrpScheduleAdminLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(3600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminLife.setDescription("This object specifies the life of all the probes included in\nthe object rttMonGrpScheduleAdminProbes, that are getting group\nscheduled. This value will be placed into\nrttMonScheduleAdminRttLife object for each of the probes listed\nin rttMonGrpScheduleAdminProbes when this conceptual control\nrow becomes 'active'.\n\nThe value 2147483647 has a special meaning. When this object is\nset to 2147483647, the rttMonCtrlOperRttLife object for all the\nprobes listed in rttMonGrpScheduleAdminProbes,  will not\ndecrement. And thus the life time of the probes will never end.")
rttMonGrpScheduleAdminAgeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2073600)).clone(3600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAgeout.setDescription("This object specifies the ageout value of all the probes\nincluded in the object rttMonGrpScheduleAdminProbes, that are\ngetting group scheduled. This value will be placed into\nrttMonScheduleAdminConceptRowAgeout object for each of the\nprobes listed in rttMonGrpScheduleAdminProbes when this\nconceptual control row becomes 'active'.\n\nWhen this value is set to zero, the probes listed in\nrttMonGrpScheduleAdminProbes, will never ageout.")
rttMonGrpScheduleAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStatus.setDescription("The status of the conceptual RTT group schedule control row.\n\nIn order for this object to become active, the following\nrow objects must be defined:\n - rttMonGrpScheduleAdminProbes\n - rttMonGrpScheduleAdminPeriod\nAll other objects can assume default values.\n\nThe conceptual RTT group schedule control row objects cannot be\nmodified once this conceptual RTT group schedule control row\nhas been created.\nOnce this object is in 'active' status, it cannot be set to\n'notInService'.\nWhen this object moves to 'active' state it will schedule the\nprobes of the rttMonCtrlAdminTable which had been created using\n'createAndWait'.\n\nThis object can be set to 'destroy' from any value at any time.\nWhen this object is set to 'destroy' it will stop all the probes\nof the rttMonCtrlAdminTable, which had been group scheduled\nby it earlier, before destroying the RTT group schedule\ncontrol row.")
rttMonGrpScheduleAdminFreqMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMax.setDescription("Specifies the max duration between initiating each RTT\noperation for all the probes specified in the group.\n\nIf this is 0 and rttMonGrpScheduleAdminFreqMin is also 0\nthen rttMonGrpScheduleAdminFrequency becomes the fixed\nfrequency.")
rttMonGrpScheduleAdminFreqMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminFreqMin.setDescription("Specifies the min duration between initiating each RTT\noperation for all the probes specified in the group.\n\nThe value of this object cannot be greater than the value of\nrttMonGrpScheduleAdminFreqMax.\n\nIf this is 0 and rttMonGrpScheduleAdminFreqMax is 0 then\nrttMonGrpScheduleAdminFrequency becomes the fixed frequency.")
rttMonGrpScheduleAdminStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminStartTime.setDescription("This is the time in seconds after which the member probes of\nthis group specified in rttMonGrpScheduleAdminProbes will\ntransition to active state")
rttMonGrpScheduleAdminAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminAdd.setDescription("Addition of members to an existing group will be allowed\nif this object is set to TRUE (1). The members, IDs of\nwhich are mentioned in rttMonGrpScheduleAdminProbes object\nare added to the existing group")
rttMonGrpScheduleAdminDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 12), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminDelete.setDescription("Removal of members from an existing group will be allowed\nif this object is set to TRUE (1). The members, IDs of\nwhich are mentioned in rttMonGrpScheduleAdminProbes object\nare removed from the existing group")
rttMonGrpScheduleAdminReset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 14, 1, 13), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonGrpScheduleAdminReset.setDescription("When this is set to true then all members\nof this group will be stopped and rescheduled using the\npreviously set values of this group.")
rttMplsVpnMonCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15))
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTable.setDescription("A table of Auto SAA L3 MPLS VPN definitions.\n\nThe Auto SAA L3 MPLS VPN administration control is in multiple\ntables.\n\nThis first table, is used to create a conceptual Auto SAA L3\nMPLS VPN control row.  The following tables contain objects\nwhich used in type specific configurations, scheduling and\nreaction configurations. All of these tables will create the\nsame conceptual control row as this table using this table's\nindex as their own index.\n\nIn order to a row in this table to become active the following\nobjects must be defined.\n  rttMplsVpnMonCtrlRttType,\n  rttMplsVpnMonCtrlVrfName and\n  rttMplsVpnMonSchedulePeriod.")
rttMplsVpnMonCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlIndex"))
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEntry.setDescription("A base list of objects that define a conceptual Auto SAA L3\nMPLS VPN control row.")
rttMplsVpnMonCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlIndex.setDescription("Uniquely identifies a row in the rttMplsVpnMonCtrlTable.\n\nThis is a pseudo-random number selected by the management\nstation when creating a row via the\nrttMplsVpnMonCtrlStatus object.\n\nIf the pseudo-random number is already in use an\n'inconsistentValue' return code will be returned when set\noperation is attempted.")
rttMplsVpnMonCtrlRttType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 2), RttMplsVpnMonRttType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRttType.setDescription("The type of RTT operation to be performed for Auto SAA L3\nMPLS VPN.\n\nThis value must be set in the same PDU of\nrttMplsVpnMonCtrlStatus.\n\nThis value must be set before setting\nany other parameter configuration of an Auto SAA L3 MPLS VPN.")
rttMplsVpnMonCtrlVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVrfName.setDescription("This field is used to specify the VPN name for which\nthe Auto SAA L3 MPLS VPN RTT operation will be used.\n\nThis value must be set in the same PDU of\nrttMplsVpnMonCtrlStatus.\n\nThe Auto SAA L3 MPLS VPN will find the PEs participating in\nthis VPN and configure RTT operation corresponding to value\nspecified in rttMplsVpnMonCtrlRttType.\n\nIf the VPN corresponds to the value configured for this object\ndoesn't exist 'inconsistentValue' error will be returned.\n\nThe value 'saa-vrf-all' has a special meaning. When this\nobject is set to 'saa-vrf-all', all the VPNs in the PE will be\ndiscovered and Auto SAA L3 MPLS VPN will configure RTT\noperations corresponding to all these PEs with the value\nspecified in rttMplsVpnMonCtrlRttType as type for those\noperations.\n\nSo, the user should avoid using this string for a particular\nVPN name when using this feature in order to avoid ambiguity.")
rttMplsVpnMonCtrlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTag.setDescription("A string which is used by a managing application to\nidentify the RTT target.\n\nThis string will be configured as rttMonCtrlAdminTag for all\nthe operations configured by this Auto SAA L3 MPLS VPN.\n\nThe usage of this value in Auto SAA L3 MPLS VPN is same as\nrttMonCtrlAdminTag in RTT operation.")
rttMplsVpnMonCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlThreshold.setDescription("This object defines an administrative threshold limit.\n\nThis value will be configured as rttMonCtrlAdminThreshold for\nall the operations that will be configured by the current\nAuto SAA L3 MPLS VPN.\n\nThe usage of this value in Auto SAA L3 MPLS VPN is same as\nrttMonCtrlAdminThreshold.")
rttMplsVpnMonCtrlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlTimeout.setDescription("Specifies the duration to wait for a RTT operation configured\nautomatically by the Auto SAA L3 MPLS VPN to complete. \n\nThe value of this object cannot be set to a value which would\nspecify a duration exceeding rttMplsVpnMonScheduleFrequency.\n\nThe usage of this value in Auto SAA L3 MPLS VPN is similar to\nrttMonCtrlAdminTimeout.")
rttMplsVpnMonCtrlScanInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 70560)).clone(240)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlScanInterval.setDescription("Specifies the frequency at which the automatic PE addition\nshould take place if there is any for an Auto SAA L3 MPLS VPN.\n\nNew RTT operations corresponding to the new PEs discovered will\nbe created and scheduled.\n\nThe default value for this object is 4 hours. The maximum value\nsupported is 49 days.")
rttMplsVpnMonCtrlDelScanFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlDelScanFactor.setDescription("Specifies the frequency at which the automatic PE deletion\nshould take place.\n\nThis object specifies the number of times of\nrttMonMplslmCtrlScanInterval (rttMplsVpnMonCtrlDelScanFactor *\nrttMplsVpnMonCtrlScanInterval) to wait before removing the PEs.\nThis object doesn't directly specify the explicit value to\nwait before removing the PEs that were down.\n\nIf this object set 0 the entries will never removed.")
rttMplsVpnMonCtrlEXP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlEXP.setDescription("This object represents the EXP value that needs to be\nput as precedence bit of an IP header.")
rttMplsVpnMonCtrlRequestSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlRequestSize.setDescription("This object represents the native payload size that needs to\nbe put on the packet.\n\nThis value will be configured as\nrttMonEchoAdminPktDataRequestSize for all the RTT operations\nconfigured by the current Auto SAA L3 MPLS VPN.\n\nThe minimum request size for jitter probe is 16. The maximum\nfor jitter probe is 1500. The default request size is 32 for\njitter probe.\n\nFor echo and pathEcho default request size is 28.\nThe minimum request size for echo and pathEcho is 28 bytes.")
rttMplsVpnMonCtrlVerifyData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlVerifyData.setDescription("When set to true, the resulting data in each RTT operation\ncreated by the current Auto SAA L3 MPLS VPN is compared with\nthe expected data. This includes checking header information\n(if possible) and exact packet size.  Any mismatch will be\nrecorded in the rttMonStatsCollectVerifyErrors object of each\nRTT operation created by the current Auto SAA L3 MPLS VPN.")
rttMplsVpnMonCtrlStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 12), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStorageType.setDescription("The storage type of this conceptual row. When set to\n'nonVolatile', this entry will be shown in 'show running'\ncommand and can be saved into Non-volatile memory.\n\nBy Default the entry will not be saved into Non-volatile\nmemory.\n\nThis object can be set to either 'volatile' or 'nonVolatile'.\nOther values are not applicable for this conceptual row and\nare not supported.")
rttMplsVpnMonCtrlProbeList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlProbeList.setDescription("This object holds the list of probes ID's that are created by\nthe Auto SAA L3 MPLS VPN.\n\nThe probes will be specified in the following form.\n(a) Individual ID's with comma separated as 1,5,3.\n(b) Range form including hyphens with multiple ranges being\n    separated by comma as 1-10,12-34.\n(c) Mix of the above two forms as 1,2,4-10,12,15,19-25.")
rttMplsVpnMonCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlStatus.setDescription("The status of the conceptual Auto SAA L3 MPLS VPN control row.\n\nIn order for this object to become active\nrttMplsVpnMonCtrlRttType,  rttMplsVpnMonCtrlVrfName and \nrttMplsVpnMonSchedulePeriod objects must be defined.\nAll other objects can assume default values.\n\nIf the object is set to 'createAndGo' rttMplsVpnMonCtrlRttType,\nrttMplsVpnMonCtrlVrfName and rttMplsVpnMonSchedulePeriod needs\nto be set along with rttMplsVpnMonCtrlStatus.\n\nIf the object is set to 'createAndWait' rttMplsVpnMonCtrlRttType\nand rttMplsVpnMonCtrlVrfName needs to be set along with\nrttMplsVpnMonCtrlStatus. rttMplsVpnMonSchedulePeriod needs to be\nspecified before setting rttMplsVpnMonCtrlStatus to 'active'.\n\nThe following objects cannot be modified after creating the\nAuto SAA L3 MPLS VPN conceptual row.\n\n - rttMplsVpnMonCtrlRttType\n - rttMplsVpnMonCtrlVrfName\n\nThe following objects can be modified even after creating the\nAuto SAA L3 MPLS VPN conceptual row by setting this object to\n'notInService'\n\n - All other writable objects in rttMplsVpnMonCtrlTable except\n   rttMplsVpnMonCtrlRttType and rttMplsVpnMonCtrlVrfName.\n - Objects in the rttMplsVpnMonTypeTable.\n - Objects in the rttMplsVpnMonScheduleTable.\n\nThe following objects can be modified as needed without setting\nthis object to 'notInService' even after creating the\nAuto SAA L3 MPLS VPN conceptual row.\n\n - Objects in rttMplsVpnMonReactTable.\n\nThis object can be set to 'destroy' from any value\nat any time. When this object is set to 'destroy' it will stop\nand destroy all the probes created by this Auto SAA L3 MPLS VPN\nbefore destroying Auto SAA L3 MPLS VPN control row.")
rttMplsVpnMonCtrlLpd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpd.setDescription("When set to true, this implies that LPD (LSP Path Discovery)\nis enabled for this row.\n\nThe Auto SAA L3 MPLS VPN will find all the paths to each of the\nPE's and configure RTT operation with rttMonCtrlAdminRttType\nvalue as 'lspGroup'. The 'lspGroup' probe will walk through\nthe list of set of information that uniquely identifies a path\nand send the LSP echo requests across them. All these LSP echo\nrequests sent for 1st path, 2nd path etc. can be thought of as\n'single probes' sent as a part of 'lspGroup'. These single\nprobes will of type 'rttMplsVpnMonCtrlRttType'.\n\n'lspGroup' probe is a superset of individual probes that will\ntest multiple paths. For example Suppose there are 10 paths to\nthe target. One 'lspGroup' probe will be created which will\nstore all the information related to uniquely identify the 10\npaths. When the 'lspGroup' probe will run it will sweep through\nthe set of information for 1st path, 2nd path, 3rd path and so\non till it has tested all the paths.")
rttMplsVpnMonCtrlLpdGrpList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdGrpList.setDescription("This object holds the list of LPD Group IDs that are created\nfor this Auto SAA L3 MPLS VPN row.\n\nThis object will be applicable only when LSP Path Discovery is\nenabled for this row.\n\nThe LPD Groups will be specified in the following form.\n(a) Individual ID's with comma separated as 1,5,3.\n(b) Range form including hyphens with multiple ranges being\n    separated by comma as 1-10,12-34.\n(c) Mix of the above two forms as 1,2,4-10,12,15,19-25.")
rttMplsVpnMonCtrlLpdCompTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 15, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMplsVpnMonCtrlLpdCompTime.setDescription("The completion time of the LSP Path Discovery for the entire\nset of PEs which are discovered for this Auto SAA.\n\nThis object will be applicable only when LSP Path Discovery is\nenabled for this row.")
rttMplsVpnMonTypeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16))
if mibBuilder.loadTexts: rttMplsVpnMonTypeTable.setDescription("A table that contains Auto SAA L3 MPLS VPN configured RTT\noperation specific definitions.\n\nThis table is controlled via the rttMplsVpnMonCtrlTable.\nEntries in this table are created via the\nrttMplsVpnMonCtrlStatus object.")
rttMplsVpnMonTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1))
if mibBuilder.loadTexts: rttMplsVpnMonTypeEntry.setDescription("A list of objects that define RTT operation specific\nconfiguration for an Auto SAA L3 MPLS VPN.")
rttMplsVpnMonTypeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeInterval.setDescription("This value represents the inter-packet delay between packets\nand is in milliseconds. This value is currently used for\nJitter probe. This object is applicable to jitter probe only.\n\nThe usage of this value in RTT operation is same as\nrttMonEchoAdminInterval.")
rttMplsVpnMonTypeNumPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeNumPackets.setDescription("This value represents the number of packets that need to be\ntransmitted. This value is currently used for Jitter probe.\nThis object is applicable to jitter probe only.\n\nThe usage of this value in RTT operation is same as\nrttMonEchoAdminNumPackets.")
rttMplsVpnMonTypeDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeDestPort.setDescription("This object represents the target's port number to which the\npackets need to be sent.\n\nThis value will be configured as target port for all the\noperations that is going to be configured \n\nThe usage of this value is same as rttMonEchoAdminTargetPort\nin RTT operation. This object is applicable to jitter type.\n\nIf this object is not being set random port will be used as\ndestination port.")
rttMplsVpnMonTypeSecFreqType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(4,1,3,2,)).subtype(namedValues=NamedValues(("none", 1), ("timeout", 2), ("connectionLoss", 3), ("both", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqType.setDescription("This object specifies the reaction type for which the\nrttMplsVpnMonTypeSecFreqValue should be applied.\n\nThe Value 'timeout' will cause secondary frequency to be set\nfor frequency on timeout condition.\n\nThe Value 'connectionLoss' will cause secondary frequency to\nbe set for frequency on connectionloss condition.\n\nThe Value 'both' will cause secondary frequency to be set for\nfrequency on either of timeout/connectionloss condition.\n\nNotifications must be configured on corresponding reaction type\nin order to rttMplsVpnMonTypeSecFreqValue get effect.\n\nWhen LSP Path Discovery is enabled for this row the following\nrttMplsVpnMonReactLpdNotifyType notifications must be\nconfigured in order to rttMplsVpnMonTypeSecFreqValue get effect.\n  - 'lpdGroupStatus' or 'lpdAll'.\n\nSince the Frequency of the operation changes the stats will be\ncollected in new bucket.\n\nIf any of the reaction type (timeout/connectionLoss) occurred\nfor an operation configured by this Auto SAA L3 MPLS VPN and\nthe following conditions are satisfied, the frequency of the\noperation will be changed to rttMplsVpnMonTypeSecFreqValue.\n\n  1) rttMplsVpnMonTypeSecFreqType is set for a reaction type\n  (timeout/connectionLoss).\n  2) A notification is configured for the same reaction type\n  (timeout/connectionLoss).\n\nWhen LSP Path Discovery is enabled for this row, if any of the\nreaction type (timeout/connectionLoss) occurred for 'single\nprobes' configured by this Auto SAA L3 MPLS VPN and the\nfollowing conditions are satisfied, the secondary frequency\nrttMplsVpnMonTypeSecFreqValue will be applied to the\n'lspGroup' probe.\n\n  1) rttMplsVpnMonTypeSecFreqType is set for a reaction type\n  (timeout/connectionLoss/both).\n  2) rttMplsVpnMonReactLpdNotifyType object must be set to\n  value of 'lpdGroupStatus' or 'lpdAll'.\n\nThe frequency of the individual operations will be restored to\noriginal frequency once the trap is sent.")
rttMplsVpnMonTypeSecFreqValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeSecFreqValue.setDescription("This object represents the value that needs to be applied to\nsecondary frequency of individual RTT operations configured by\nAuto SAA L3 MPLS VPN.\n\nSetting rttMplsVpnMonTypeSecFreqValue without setting\nrttMplsVpnMonTypeSecFreqType will not have any effect.")
rttMplsVpnMonTypeLspSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 6), OctetString().clone('7F 00 00 01')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLspSelector.setDescription("A string which specifies the address of the local host\n(127.X.X.X).\n\nThis object will be used as lsp-selector in MPLS RTT\noperations configured by the Auto SAA L3 MPLS VPN.\n\nWhen LSP Path Discovery is enabled for the row, this object will\nbe used to indicate the base LSP selector value to be used in\nthe LSP Path Discovery.\n\nThis value of this object is significant in MPLS load\nbalancing scenario. This value will be used as one of the\nparameter in that load balancing.")
rttMplsVpnMonTypeLSPReplyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 7), RttMonLSPPingReplyMode().clone('replyIpv4Udp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyMode.setDescription("This object specifies the reply mode for the LSP Echo\nrequests originated by the operations configured by the\nAuto SAA L3 MPLS VPN.\n\nThis object is currently used by echo and pathEcho.")
rttMplsVpnMonTypeLSPTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPTTL.setDescription("This object represents the TTL setting for MPLS echo request\npackets originated by the operations configured by the\nAuto SAA L3 MPLS VPN.\n\nThis object is currently used by echo and pathEcho.\n\nFor 'echo' the default TTL will be set to 255.\nFor 'pathEcho' the default will be set to 30.\n\nNote: This object cannot be set to the value of 0. The\ndefault value of 0 signifies the default TTL values will be\nused for 'echo' and 'pathEcho'.")
rttMplsVpnMonTypeLSPReplyDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,63),ValueRangeConstraint(255,255),)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLSPReplyDscp.setDescription("This object specifies the DSCP value to be set in the IP header\nof the LSP echo reply packet.\nThe value of this object will be in range of DiffServ codepoint\nvalues between 0 to 63.\n\nNote: This object cannot be set to value of 255. This default\nvalue specifies that DSCP is not set for this row.")
rttMplsVpnMonTypeLpdMaxSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdMaxSessions.setDescription("This object represents the number of concurrent path discovery\nrequests that will be active at one time per MPLS VPN control\nrow. This object is meant for reducing the time for discovery\nof all the paths to the target in a large customer network.\nHowever its value should be chosen such that it does not cause\nany performance impact.\n\nNote: If the customer network has low end routers in the Core\nit is recommended to keep this value low.")
rttMplsVpnMonTypeLpdSessTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900)).clone(120)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdSessTimeout.setDescription("This object specifies the maximum allowed duration of a\nparticular tree trace request.\n\nIf no response is received in configured time the request will\nbe considered a failure.")
rttMplsVpnMonTypeLpdEchoTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800000)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoTimeout.setDescription("This object specifies the timeout value for the LSP echo\nrequests which are sent while performing the LSP Path \nDiscovery.")
rttMplsVpnMonTypeLpdEchoInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoInterval.setDescription("This object specifies the send interval between LSP echo\nrequests which are sent while performing the LSP Path \nDiscovery.")
rttMplsVpnMonTypeLpdEchoNullShim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdEchoNullShim.setDescription("This object specifies if the explicit-null label is added to\nLSP echo requests which are sent while performing the LSP Path\nDiscovery.\n\nIf set to TRUE all the probes configured as part of this control\nrow will send the LSP echo requests with the explicit-null\nlabel added.")
rttMplsVpnMonTypeLpdScanPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7200)).clone(240)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdScanPeriod.setDescription("This object specifies the scan time for the completion of LSP\nPath Discovery for all the PEs discovered for this control row.\nIf the scan period is exceeded on completion of the LSP Path\nDiscovery for all the PEs, the next discovery will start\nimmediately else it will wait till expiry of scan period.\n\nFor example: If the value is set to 30 minutes then on start of\nthe LSP Path Discovery a timestamp will be taken say T1. At the\nend of the tree trace discovery one more timestamp will be taken\nagain say T2. If (T2-T1) is greater than 30, the next discovery\nwill start immediately else next discovery  will wait for\n[30 - (T2-T1)].\n\nNote: If the object is set to a special value of '0', it will\nforce immediate start of the next discovery on all neighbours\nwithout any delay.")
rttMplsVpnMonTypeLpdStatHours = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 16, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonTypeLpdStatHours.setDescription("The maximum number of hours of data to be kept per LPD\ngroup. The LPD group statistics will be kept in an hourly\nbucket. At the maximum there can be two buckets.\nThe value of 'one' is not advisable because the group will close\nand immediately be deleted before the network management station\nwill have the opportunity to retrieve the statistics.\n\nThe value used in the rttMplsVpnLpdGroupStatsTable to\nuniquely identify this group is the\nrttMonStatsCaptureStartTimeIndex.\n\nNote: When this object is set to the value of '0' all\nrttMplsVpnLpdGroupStatsTable data capturing will be shut off.")
rttMplsVpnMonScheduleTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17))
if mibBuilder.loadTexts: rttMplsVpnMonScheduleTable.setDescription("A table of Auto SAA L3 MPLS VPN monitoring scheduling\nspecific definitions.\n\nThis table is controlled via the rttMplsVpnMonCtrlTable.\nEntries in this table are created via the\nrttMplsVpnMonCtrlStatus object.")
rttMplsVpnMonScheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1))
if mibBuilder.loadTexts: rttMplsVpnMonScheduleEntry.setDescription("A list of objects that define specific configuration for\nthe scheduling of RTT operations.")
rttMplsVpnMonScheduleRttStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 1), TimeTicks().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonScheduleRttStartTime.setDescription("This is the time when this conceptual row will\nactivate. rttMplsVpnMonSchedulePeriod object must be specified\nbefore setting this object.\n\nThis is the value of MIB-II's sysUpTime in the future.\nWhen sysUpTime equals this value this object will\ncause the activation of a conceptual Auto SAA L3 MPLS VPN row.\n\nWhen an agent has the capability to determine date and\ntime, the agent should store this object as DateAndTime.\nThis allows the agent to be able to activate conceptual\nAuto SAA L3 MPLS VPN row at the intended time.\n\nIf this object has value as 1, this means start the operation\nnow itself. Value of 0 puts the operation in pending state.")
rttMplsVpnMonSchedulePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonSchedulePeriod.setDescription("Specifies the time duration over which all the probes created\nby the current Auto SAA L3 MPLS VPN have to be scheduled.\n\nThis object must be set first before setting\nrttMplsVpnMonScheduleRttStartTime.")
rttMplsVpnMonScheduleFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 604800)).clone(60)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonScheduleFrequency.setDescription("Specifies the duration between initiating each RTT\noperation configured by the Auto SAA L3 MPLS VPN.\n\nThis object cannot be set to a value which would be a\nshorter duration than rttMplsVpnMonCtrlTimeout.\n\nThe usage of this value in RTT operation is same as\nrttMonCtrlAdminFrequency.")
rttMplsVpnMonReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18))
if mibBuilder.loadTexts: rttMplsVpnMonReactTable.setDescription("A Table of Auto SAA L3 MPLS VPN Notification definitions.\n\nThis table augments the rttMplsVpnMonCtrlTable.")
rttMplsVpnMonReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1))
if mibBuilder.loadTexts: rttMplsVpnMonReactEntry.setDescription("A list of objects that define Auto SAA L3 MPLS VPN reaction\nconfiguration.")
rttMplsVpnMonReactConnectionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactConnectionEnable.setDescription("The value set for this will be applied as\nrttMonReactAdminConnectionEnable for individual probes created\nby the Auto SAA L3 MPLS VPN.\n\nWhen this object is set to true, rttMonReactVar for individual\nprobes created by the Auto SAA L3 MPLS VPN will be set to\n'connectionLoss(8)'.")
rttMplsVpnMonReactTimeoutEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactTimeoutEnable.setDescription("The value set for this will be applied as\nrttMonReactAdminTimeoutEnable for individual probes created\nby the Auto SAA L3 MPLS VPN.\n\nWhen this object is set to true, rttMonReactVar for individual\nprobes created by the Auto SAA L3 MPLS VPN will be set to\n'timeout(7)'.")
rttMplsVpnMonReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdType.setDescription("The value corresponding to this object will be applied as\nrttMonReactAdminThresholdType for individual probes created by\nthe Auto SAA L3 MPLS VPN.\n\nThe value corresponding to this object will be applied as\nrttMonReactThresholdType for individual probes created by\nthe Auto SAA L3 MPLS VPN.")
rttMplsVpnMonReactThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactThresholdCount.setDescription("This object value will be applied as\nrttMonReactAdminThresholdCount for individual probes created by\nthe Auto SAA L3 MPLS VPN.\n\nThis object value will be applied as rttMonReactThresholdCountX\nfor individual probes created by the Auto SAA L3 MPLS VPN.")
rttMplsVpnMonReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("none", 1), ("trapOnly", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactActionType.setDescription("The value corresponding to this object will be applied as\nrttMonReactAdminActionType of individual probes created by\nthis Auto SAA L3 MPLS VPN.\n\nThe value corresponding to this object will be applied as\nrttMonReactActionType of individual probes created by\nthis Auto SAA L3 MPLS VPN.")
rttMplsVpnMonReactLpdNotifyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,4,2,)).subtype(namedValues=NamedValues(("none", 1), ("lpdPathDiscovery", 2), ("lpdGroupStatus", 3), ("lpdAll", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdNotifyType.setDescription("This object specifies the type of LPD notifications to be\ngenerated for the current Auto SAA L3 MPLS VPN control row.\n\nThis object will be applicable only when LSP Path Discovery is\nenabled for this row.\n\nThere are two types of notifications supported for the LPD -\n(a) rttMonLpdDiscoveryNotification - This notification will\n    be sent on the failure of LSP Path Discovery to the\n    particular PE. Reversal of the failure will also result in\n    sending the notification.\n(b) rttMonLpdGrpStatusNotification - Individual probes in an LPD\n    group will not generate notifications independently but will\n    be generating dependent on the state of the group. Any\n    individual probe can initiate the generation of a\n    notification, dependent on the state of the group.\n    Notifications are only generated if the failure/restoration\n    of an individual probe causes the state of the group to\n    change.\n\nThe Value 'none' will not cause any notifications to be sent.\n\nThe Value 'lpdPathDiscovery' will cause (a) to be sent.\n\nThe Value 'lpdGroupStatus' will cause (b) to be sent.\n\nThe Value 'lpdAll' will cause both (a) and (b) to sent\ndepending on the failure conditions.")
rttMplsVpnMonReactLpdRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 18, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMplsVpnMonReactLpdRetryCount.setDescription("This object value specifies the number of attempts to be\nperformed before declaring the path as 'down'. Each 'single\nprobe' which is part of 'lspGroup' probe will be retried these\nmany times before marking it as 'down'.\n\nThis object will be applicable only when LSP Path Discovery is\nenabled for this row.\n\n  - When rttMplsVpnMonTypeSecFreqType is not configured, the\n    failure count will be incremented at the next cycle of\n    'lspGroup' probe at interval's of\n    rttMplsVpnMonScheduleFrequency value.\n\n    For example: Assume there are 10 paths discovered and on\n    the first run of the 'lspGroup' probe first two paths failed\n    and rest passed. On the second run all the probes will be \n    run again. The probes 1 and 2 will be retried till the\n    rttMplsVpnMonReactLpdRetryCount value, and\n    then marked as 'down' and rttMonLpdGrpStatusNotification \n    will be sent if configured.\n\n  - When rttMplsVpnMonTypeSecFreqType value is anything other\n    than 'none', the retry will happen for the failed probes at\n    the rttMplsVpnMonTypeSecFreqValue and only the failed\n    probes will be retried.\n\n    For example: Assume there are 10 paths discovered and on the\n    first run of the 'lspGroup' probe first two paths failed and\n    rest passed. The secondary frequency will be applied to the\n    failed probes. At secondary frequency interval the first two\n    probes will be run again. The probes 1 and 2 will be retried\n    till the rttMplsVpnMonReactLpdRetryCount value, and\n    then marked as 'down' and rttMonLpdGrpStatusNotification \n    will be sent if configured.")
rttMonReactTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19))
if mibBuilder.loadTexts: rttMonReactTable.setDescription("A table that contains the reaction configurations. Each\nconceptual row in rttMonReactTable corresponds to a reaction\nconfigured for the probe defined in rttMonCtrlAdminTable.\n\nFor each reaction configured for a probe there is an entry in\nthe table.\n\nEach Probe can have multiple reactions and hence there can be\nmultiple rows for a particular probe.\n\nThis table is coupled with rttMonCtrlAdminTable.")
rttMonReactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonReactConfigIndex"))
if mibBuilder.loadTexts: rttMonReactEntry.setDescription("A base list of objects that define a conceptual reaction\nconfiguration control row.")
rttMonReactConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonReactConfigIndex.setDescription("This object along with rttMonCtrlAdminIndex identifies\na particular reaction-configuration for a particular probe.\nThis is a pseudo-random number selected by the management\nstation when creating a row via the rttMonReactStatus.\nIf the pseudo-random number is already in use an\n'inconsistentValue' return code will be returned when\nset operation is attempted.")
rttMonReactVar = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 2), RttMonReactVar()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactVar.setDescription("This object specifies the type of reaction configured for a\nprobe.\n\nThe reaction types 'rtt', 'timeout', and 'connectionLoss' \ncan be configured for all probe types.\n\nThe reaction type 'verifyError' can be configured for all \nprobe types except RTP probe type.\n\nThe reaction types 'jitterSDAvg', 'jitterDSAvg', 'jitterAvg', \n'packetLateArrival', 'packetOutOfSequence', \n'maxOfPositiveSD', 'maxOfNegativeSD', 'maxOfPositiveDS'\nand 'maxOfNegativeDS' can be configured for UDP jitter \nand ICMP jitter probe types only.\n\nThe reaction types 'mos' and 'icpif' can be configured \nfor UDP jitter and ICMP jitter probe types only.\n\nThe reaction types 'packetLossDS', 'packetLossSD' and \n'packetMIA' can be configured for UDP jitter, and \nRTP probe types only.\n\nThe reaction types 'iaJitterDS', 'frameLossDS', 'mosLQDS', \n'mosCQDS', 'rFactorDS', 'iaJitterSD', 'rFactorSD', 'mosCQSD' \ncan be configured for RTP probe type only.\n\nThe reaction types 'successivePacketLoss', 'maxOfLatencyDS', \n'maxOfLatencySD', 'latencyDSAvg', 'latencySDAvg' and \n'packetLoss' can be configured for ICMP jitter probe \ntype only.")
rttMonReactThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(4,5,1,2,3,)).subtype(namedValues=NamedValues(("never", 1), ("immediate", 2), ("consecutive", 3), ("xOfy", 4), ("average", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdType.setDescription("This object specifies the conditions under which\nthe notification ( trap ) is sent.\n\nnever       - rttMonReactOccurred is never set\n\nimmediate   - rttMonReactOccurred is set to 'true' when the\n              value of parameter for which reaction is\n              configured ( e.g rtt, jitterAvg, packetLossSD,\n              mos etc ) violates the threshold.\n              Conversely, rttMonReactOccurred is set to 'false'\n              when the parameter ( e.g rtt, jitterAvg,\n              packetLossSD, mos etc ) is below the threshold\n              limits.\n\nconsecutive - rttMonReactOccurred is set to true when the value\n              of parameter for which reaction is configured\n              ( e.g rtt, jitterAvg, packetLossSD, mos etc )\n              violates the threshold for configured consecutive\n              times.\n              Conversely, rttMonReactOccurred is set to false\n              when the value of parameter ( e.g rtt, jitterAvg\n              packetLossSD, mos etc ) is below the threshold\n              limits for the same number of consecutive\n              operations.\n\nxOfy        - rttMonReactOccurred is set to true when x\n              ( as specified by rttMonReactThresholdCountX )\n              out of the last y ( as specified by\n              rttMonReacthresholdCountY ) times the value of\n              parameter for which the reaction is configured\n              ( e.g rtt, jitterAvg, packetLossSD, mos etc )\n              violates the threshold.\n              Conversely, it is set to false when x, out of the\n              last y times the value of parameter\n              ( e.g rtt, jitterAvg, packetLossSD, mos ) is\n              below the threshold limits.\n              NOTE: When x > y, the probe will never\n                    generate a reaction.\n\naverage    - rttMonReactOccurred is set to true when the\n             average ( rttMonReactThresholdCountX times )\n             value of parameter for which reaction is \n             configured ( e.g rtt, jitterAvg, packetLossSD,\n             mos etc ) violates the threshold condition.\n             Conversely, it is set to false when the\n             average value of parameter ( e.g rtt, jitterAvg,\n             packetLossSD, mos etc ) is below the threshold\n             limits.\n\nIf this value is changed by a management station,\nrttMonReactOccurred is set to false, but\nno reaction is generated if the prior value of\nrttMonReactOccurred was true.")
rttMonReactActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("none", 1), ("trapOnly", 2), ("triggerOnly", 3), ("trapAndTrigger", 4), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactActionType.setDescription("Specifies what type(s), if any, of reaction(s) to\ngenerate if an operation violates one of the watched\n( reaction-configuration ) conditions:\n\nnone               - no reaction is generated\ntrapOnly           - a trap is generated\ntriggerOnly        - all trigger actions defined for this\n                     entry are initiated\ntrapAndTrigger     - both a trap and all trigger actions\n                     are initiated\nA trigger action is defined via the\nrttMonReactTriggerAdminTable.")
rttMonReactThresholdRising = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdRising.setDescription("This object defines the higher threshold limit.\nIf the value ( e.g rtt, jitterAvg, packetLossSD etc ) rises\nabove this limit and if the condition specified in\nrttMonReactThresholdType are satisfied, a trap is generated.\n\nDefault value of rttMonReactThresholdRising for\n   'rtt' is 5000\n   'jitterAvg' is 100.\n   'jitterSDAvg' is 100.\n   'jitterDSAvg' 100.\n   'packetLossSD' is 10000.\n   'packetLossDS' is 10000.\n   'mos' is 500.\n   'icpif' is 93.\n   'packetMIA' is 10000.\n   'packetLateArrival' is 10000.\n   'packetOutOfSequence' is 10000.\n   'maxOfPositiveSD' is 10000.\n   'maxOfNegativeSD' is 10000.\n   'maxOfPositiveDS' is 10000.\n   'maxOfNegativeDS' is 10000.\n   'iaJitterDS' is 20.\n   'frameLossDS' is 10000.\n   'mosLQDS' is 400.\n   'mosCQDS' is 400.\n   'rFactorDS' is 80.\n   'successivePacketLoss' is 1000.\n   'maxOfLatencyDS' is 5000.\n   'maxOfLatencySD' is 5000.\n   'latencyDSAvg' is 5000.\n   'latencySDAvg' is 5000.\n   'packetLoss' is 10000.\n\nThis object is not applicable if the rttMonReactVar is\n'timeout', 'connectionLoss' or 'verifyError'. For 'timeout',\n'connectionLoss' and 'verifyError' default value of \nrttMonReactThresholdRising will be 0.")
rttMonReactThresholdFalling = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdFalling.setDescription("This object defines a lower threshold limit. If the\nvalue ( e.g rtt, jitterAvg, packetLossSD etc ) falls\nbelow this limit and if the conditions specified in\nrttMonReactThresholdType are satisfied, a trap is generated.\n\nDefault value of rttMonReactThresholdFalling\n   'rtt' is 3000\n   'jitterAvg' is 100.\n   'jitterSDAvg' is 100.\n   'jitterDSAvg' 100.\n   'packetLossSD' is 10000.\n   'packetLossDS' is 10000.\n   'mos' is 500.\n   'icpif' is 93.\n   'packetMIA' is 10000.\n   'packetLateArrival' is 10000.\n   'packetOutOfSequence' is 10000.\n   'maxOfPositiveSD' is 10000.\n   'maxOfNegativeSD' is 10000.\n   'maxOfPositiveDS' is 10000.\n   'maxOfNegativeDS' is 10000.\n   'iaJitterDS' is 20.\n   'frameLossDS' is 10000.\n   'mosLQDS' is 310.\n   'mosCQDS' is 310.\n   'rFactorDS' is 60.\n   'successivePacketLoss' is 1000.\n   'maxOfLatencyDS' is 3000.\n   'maxOfLatencySD' is 3000.\n   'latencyDSAvg' is 3000.\n   'latencySDAvg' is 3000.\n   'packetLoss' is 10000.\n   'iaJitterSD' is 20.\n   'mosCQSD' is 310.\n   'rFactorSD' is 60.\n\nThis object is not applicable if the rttMonReactVar is\n'timeout', 'connectionLoss' or 'verifyError'. For 'timeout',\n'connectionLoss' and 'verifyError' default value of\nrttMonReactThresholdFalling will be 0.")
rttMonReactThresholdCountX = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdCountX.setDescription("If rttMonReactThresholdType value is 'xOfy', this object\ndefines the 'x' value.\n\nIf rttMonReactThresholdType value is 'consecutive'\nthis object defines the number of consecutive occurrences\nthat needs threshold violation before setting \nrttMonReactOccurred as true.\n\nIf rttMonReactThresholdType value is 'average' this object\ndefines the number of samples that needs be considered for\ncalculating average.\n\nThis object has no meaning if rttMonReactThresholdType has\nvalue of 'never' and 'immediate'.")
rttMonReactThresholdCountY = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactThresholdCountY.setDescription("This object defines the 'y' value of the xOfy condition\nif rttMonReactThresholdType is 'xOfy'.\n\nFor other values of rttMonReactThresholdType, this object\nis not applicable.")
rttMonReactValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactValue.setDescription("This object will be set when the configured threshold condition\nis violated as defined by rttMonReactThresholdType and holds the\nactual value that violated the configured threshold values.\n\nThis object is not valid for the following values of\nrttMonReactVar and It will be always 0:\n  - timeout\n  - connectionLoss\n  - verifyError.")
rttMonReactOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 10), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonReactOccurred.setDescription("This object is set to true when the configured threshold\ncondition is violated as defined by rttMonReactThresholdType.\nIt will be again set to 'false' if the condition reverses.\n\nThis object is set to true in the following conditions:\n - rttMonReactVar is set to timeout and\n   rttMonCtrlOperTimeoutOccurred set to true.\n - rttMonReactVar is set to connectionLoss and\n   rttMonCtrlOperConnectionLostOccurred set to true.\n - rttMonReactVar is set to verifyError and\n   rttMonCtrlOperVerifyErrorOccurred is set to true.\n - For all other values of rttMonReactVar, if the\n   corresponding value exceeds the configured\n   rttMonReactThresholdRising.\n\n This object is set to false in the following conditions:\n - rttMonReactVar is set to timeout and\n   rttMonCtrlOperTimeoutOccurred set to false.\n - rttMonReactVar is set to connectionLoss and \n   rttMonCtrlOperConnectionLostOccurred set to false.\n - rttMonReactVar is set to verifyError and\n   rttMonCtrlOperVerifyErrorOccurred is set to false.\n - For all other values of rttMonReactVar, if the\n   corresponding value fall below the configured \n   rttMonReactThresholdFalling.\n\nWhen the RttMonRttType is 'pathEcho' or 'pathJitter',\nthis object is applied only to the \nrttMonEchoAdminTargetAddress and not to intermediate\nhops to the Target.")
rttMonReactStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 19, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rttMonReactStatus.setDescription("This objects indicates the status of the conceptual RTT\nReaction Control Row.Only CreateAndGo and destroy \noperations are permitted on the row.\n\nWhen this object moves to active state, the conceptual row\nhaving the Reaction configuration for the probe is monitored\nand the notifications are generated when the threshold violation\ntakes place.\n\nIn order for this object to become active rttMonReactVar must\nbe defined. All other objects assume the default value.\n\nThis object can be set to 'destroy' from any value at any time.\nWhen this object is set to 'destroy' no reaction configuration\nfor the probes would exist. The reaction configuration for the\nprobe is removed.")
rttMonGeneratedOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20))
if mibBuilder.loadTexts: rttMonGeneratedOperTable.setDescription("This table contains information about the generated\noperation id as part of a parent IP SLA operation. The parent\noperation id is pseudo-random number, selected by the management \nstation based on an operation started by the management \nstation,when creating a row via the rttMonCtrlAdminStatus\nobject in the rttMonCtrlAdminTable table.")
rttMonGeneratedOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonGeneratedOperRespIpAddrType"), (0, "CISCO-RTTMON-MIB", "rttMonGeneratedOperRespIpAddr"))
if mibBuilder.loadTexts: rttMonGeneratedOperEntry.setDescription("An entry in the Generated Oper table corresponding to\na child or generated operation as part of a parent\nIP SLA operation.")
rttMonGeneratedOperRespIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddrType.setDescription("The type of Internet address, IPv4 or IPv6, of a responder\nfor an IP SLA operation.")
rttMonGeneratedOperRespIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonGeneratedOperRespIpAddr.setDescription("The internet address of a responder for IP SLA\noperation. The type of this address is determined\nby the value of rttMonGeneratedOperRespIpAddrType.")
rttMonGeneratedOperCtrlAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 2, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonGeneratedOperCtrlAdminIndex.setDescription("This is a pseudo-random number, auto-generated based\nto identify a child operation based on a parent \noperation started by the management station,when \ncreating a row via the rttMonCtrlAdminStatus\nobject.")
rttMonStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3))
rttMonStatsCaptureTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1))
if mibBuilder.loadTexts: rttMonStatsCaptureTable.setDescription("The statistics capture database.\n\nThe statistics capture table contains summarized \ninformation of the results for a conceptual RTT control \nrow.  A rolling accumulated history of this information \nis maintained in a series of hourly 'group(s)'.  Each \n'group' contains a series of 'path(s)', each 'path' \ncontains a series of 'hop(s)', each 'hop' contains a \nseries of 'statistics distribution bucket(s)'.\n\nEach conceptual statistics row has a current hourly \ngroup, into which RTT results are accumulated.  At the \nend of each hour a new hourly group is created which \nthen becomes current.  The counters and accumulators in \nthe new group are initialized to zero.  The previous \ngroup(s) is kept in the table until the table contains \nrttMonStatisticsAdminNumHourGroups groups for the \nconceptual statistics row;  at this point, the oldest \ngroup is discarded and is replaced by the newly created \none.  The hourly group is uniquely identified by the \nrttMonStatsCaptureStartTimeIndex object.\n\nIf the activity for a conceptual RTT control row ceases \nbecause the rttMonCtrlOperState object transitions to \n'inactive', the corresponding current hourly group in \nthis table is 'frozen', and a new hourly group is \ncreated when activity is resumed.\n\nIf the activity for a conceptual RTT control row ceases \nbecause the rttMonCtrlOperState object transitions to \n'pending' this whole table will be cleared and reset to \nits initial state.\n\nWhen the RttMonRttType is 'pathEcho', the path \nexploration RTT requests' statistics will not be \naccumulated in this table.\n\nNOTE: When the RttMonRttType is 'pathEcho', a source to \n      target rttMonStatsCapturePathIndex path will be \n      created for each rttMonStatsCaptureStartTimeIndex \n      to hold all errors that occur when a specific path\n      had not been found or connection has not be setup.\n\nUsing this rttMonStatsCaptureTable, a managing \napplication can retrieve summarized data from accurately \nmeasured periods, which is synchronized across multiple \nconceptual RTT control rows.  With the new hourly group\ncreation being performed on a 60 minute period, the \nmanaging station has plenty of time to collect the data, \nand need not be concerned with the vagaries of network \ndelays and lost PDU's when trying to get matching data.  \nAlso, the managing station can spread the data gathering \nover a longer period, which removes the need for a flood \nof get requests in a short period which otherwise would \noccur.")
rttMonStatsCaptureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCapturePathIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureHopIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureDistIndex"))
if mibBuilder.loadTexts: rttMonStatsCaptureEntry.setDescription("A list of objects which accumulate the results of a\nseries of RTT operations over a 60 minute time period.\n\nThe statistics capture table is a rollover table.  When\nrttMonStatsCaptureStartTimeIndex groups exceeds the \nrttMonStatisticsAdminNumHourGroups value, the oldest \ncorresponding hourly group will be deleted and will be \nreplaced with the new rttMonStatsCaptureStartTimeIndex\nhourly group.  \n\nAll other indices will fill to there maximum size. \n\nThe statistics capture table has five indices.  Each\ndescribed as follows:\n\n  -  The first index correlates its entries to a\n      conceptual RTT control row via the \n      rttMonCtrlAdminIndex object.\n  -  The second index is a rollover group and it \n      uniquely identifies a 60 minute group. (The \n      rttMonStatsCaptureStartTimeIndex object\n      is used to make this value unique.)\n  -  When the RttMonRttType is 'pathEcho', the third \n      index uniquely identifies the paths in a \n      statistics period.  (The period is 60\n      minutes.)  A path will be created for each\n      unique path through the network.  Note:  A\n      path that does not contain the target is\n      considered a different path than one which\n      uses the exact same path, but does contain the\n      target.  For all other values of RttMonRttType\n      this index will be one.\n  -  When the RttMonRttType is 'pathEcho', the fourth \n      index uniquely identifies the hops in each path, \n      as grouped by the third index.  This index does \n      imply the order of the hops along the path to a \n      target.  For all other values of RttMonRttType\n      this index will be one.\n  -  The fifth index uniquely creates a statistical\n      distribution bucket.")
rttMonStatsCaptureStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 1), TimeStamp()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonStatsCaptureStartTimeIndex.setDescription("The time when this row was created.\n\nThis object is the second index of the \nrttMonStatsCaptureTable Table.\n\nThe the number of rttMonStatsCaptureStartTimeIndex  \ngroups exceeds the rttMonStatisticsAdminNumHourGroups\nvalue, the oldest rttMonStatsCaptureStartTimeIndex \ngroup will be removed and replaced with the new entry.\n\nWhen the RttMonRttType is 'pathEcho', this object also \nuniquely defines a group of paths.  See the \nrttMonStatsCaptureEntry object.")
rttMonStatsCapturePathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonStatsCapturePathIndex.setDescription("When the RttMonRttType is 'pathEcho', this object\nuniquely defines a path for a given value of \nrttMonStatsCaptureStartTimeIndex.  For all other values\nof RttMonRttType, this object will be one.\n\nFor a particular value of \nrttMonStatsCaptureStartTimeIndex, the agent assigns the\nfirst instance of a path a value of 1, then second \ninstance a value of 2, and so on.  The sequence keeps \nincrementing until the number of paths equals \nrttMonStatisticsAdminNumPaths value, then no new paths \nare kept for the current rttMonStatsCaptureStartTimeIndex \ngroup.\n\nNOTE: A source to target rttMonStatsCapturePathIndex\n      path will be created for each \n      rttMonStatsCaptureStartTimeIndex to hold all \n      errors that occur when a specific path or \n      connection has not be setup.\n\nThis value directly represents the path to\na target. We can only support 128 paths.")
rttMonStatsCaptureHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonStatsCaptureHopIndex.setDescription("When the RttMonRttType is 'pathEcho', this object\nuniquely defines a hop for a given value of \nrttMonStatsCapturePathIndex.  For all other values of\nRttMonRttType, this object will be one.\n\nFor a particular value of rttMonStatsCapturePathIndex,\nthe agent assigns the first instance of a hop\na value of 1, then second instance a value of 2, and so\non.  The sequence keeps incrementing until the number of \nhops equals rttMonStatisticsAdminNumHops value, then\nno new hops are kept for the current\nrttMonStatsCapturePathIndex.\n\nThis value directly represents a hop along the path to\na target, thus we can only support 30 hops.\n\nThis value shows the order along the path to a target.")
rttMonStatsCaptureDistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonStatsCaptureDistIndex.setDescription("This object uniquely defines a statistical distribution\nbucket for a given value of rttMonStatsCaptureHopIndex.\n\nFor a particular value of rttMonStatsCaptureHopIndex,\nthe agent assigns the first instance of a distribution\na value of 1, then second instance a value of 2, and so\non.  The sequence keeps incrementing until the number of \nstatistics distribution intervals equals \nrttMonStatisticsAdminNumDistBuckets value, then\nall values that fall above the last interval will\nbe placed into the last interval.\n\nEach of these Statistics Distribution Buckets contain \nthe results of each completion as defined by \nrttMonStatisticsAdminDistInterval object.")
rttMonStatsCaptureCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletions.setDescription("The number of RTT operations that have completed without\nan error and without timing out.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCaptureOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureOverThresholds.setDescription("The number of RTT operations successfully completed, but\nin excess of rttMonCtrlAdminThreshold.  This number is a\nsubset of the accumulation of all \nrttMonStatsCaptureCompletions.  The operation time \nof these completed operations will be accumulated.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCaptureSumCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime.setDescription("The accumulated completion time of RTT operations which\ncomplete successfully.")
rttMonStatsCaptureSumCompletionTime2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2Low.setDescription("The low order 32 bits of the accumulated squares\nof completion times (in milliseconds) of RTT \noperations which complete successfully.\n\nLow/High order is defined where the binary number\nwill look as follows:\n-------------------------------------------------\n| High order 32 bits    | Low order 32 bits     |\n-------------------------------------------------\nFor example the number 4294967296 would have all\nLow order bits as '0' and the rightmost High\norder bit will be 1 (zeros,1).")
rttMonStatsCaptureSumCompletionTime2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureSumCompletionTime2High.setDescription("The high order 32 bits of the accumulated squares\nof completion times (in milliseconds) of RTT \noperations which complete successfully.\n\nSee the rttMonStatsCaptureSumCompletionTime2Low object\nfor a definition of Low/High Order.")
rttMonStatsCaptureCompletionTimeMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMax.setDescription("The maximum completion time of any RTT operation which\ncompletes successfully.")
rttMonStatsCaptureCompletionTimeMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCaptureCompletionTimeMin.setDescription("The minimum completion time of any RTT operation which\ncompletes successfully.")
rttMonStatsCollectTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2))
if mibBuilder.loadTexts: rttMonStatsCollectTable.setDescription("The statistics collection database.\n\nThis table has the exact same behavior as the\nrttMonStatsCaptureTable, except it does not keep\nstatistical distribution information.\n\nFor a complete table description see\nthe rttMonStatsCaptureTable object.")
rttMonStatsCollectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCapturePathIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureHopIndex"))
if mibBuilder.loadTexts: rttMonStatsCollectEntry.setDescription("A list of objects which accumulate the results of a\nseries of RTT operations over a 60 minute time period.\n\nThis entry has the exact same behavior as the \nrttMonStatsCaptureEntry, except it does not keep\nstatistical distribution information.\n\nFor a complete entry description see\nthe rttMonStatsCaptureEntry object.")
rttMonStatsCollectNumDisconnects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectNumDisconnects.setDescription("When the RttMonRttType is 'echo' or pathEcho', this\nobject represents the number of times that the target or \nhop along the path to a target became disconnected.  For\nall other values of RttMonRttType, this object will\nremain zero.\n\nFor connectionless protocols this has no meaning,\nand will consequently remain 0.  When\nrttMonEchoAdminProtocol is one of snaRUEcho, this is\nthe number of times that an LU-SSCP session was lost, \nfor snaLU0EchoAppl, snaLU2EchoAppl, snaLu62Echo, and for \nsnaLU62EchoAppl, this is the number of times that LU-LU \nsession was lost.\n\nSince this error does not indicate any information about\nthe failure of an RTT operation, no response time \ninformation for this instance will be recorded in the \nappropriate objects.\n\nIf this error occurs and the rttMonStatsCapturePathIndex \ncannot be determined, this error will be accumulated in \nthe source to target path, that will always exist.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectTimeouts.setDescription("The number of occasions when a RTT operation was not\ncompleted before a timeout occurred, i.e.\nrttMonCtrlAdminTimeout was exceeded.\n\nSince the RTT operation was never completed, the \ncompletion time of these operations are not accumulated,\nnor do they increment rttMonStatsCaptureCompletions (in \nany of the statistics distribution buckets).\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectBusies.setDescription("The number of occasions when a RTT operation could not\nbe initiated because a previous RTT operation has not \nbeen completed.\n\nWhen the RttMonRttType is 'pathEcho' this can occur for\nboth connection oriented protocols and connectionless\nprotocols.\n\nWhen the RttMonRttType is 'echo' this can only occur for\nconnection oriented protocols such as SNA. \n\nWhen the initiation of a new operation cannot be started,\nthis object will be incremented and the operation will be\nomitted.  (The next operation will start at the next \nFrequency).  Since, a RTT operation was never initiated, \nthe completion time of these operations is not \naccumulated, nor do they increment \nrttMonStatsCaptureCompletions.\n\nWhen the RttMonRttType is 'pathEcho', and this error \noccurs and the rttMonStatsCapturePathIndex cannot be \ndetermined, this error will be accumulated in the source \nto target path, that will always exist.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectNoConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectNoConnections.setDescription("When the RttMonRttType is 'echo' or 'pathEcho' this is\nthe number of occasions when a RTT operation could not be\ninitiated because the connection to the target has not \nbeen established.  For all other RttMonRttTypes this\nobject will remain zero.\n\nThis cannot occur for connectionless protocols, but may\noccur for connection oriented protocols, such as SNA.\n\nSince a RTT operation was never initiated, the completion\ntime of these operations are not accumulated, nor do they\nincrement rttMonStatsCaptureCompletions. \n\nIf this error occurs and the rttMonStatsCapturePathIndex\ncannot be determined, this error will be accumulated\nin the source to target path, that will always exist.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectDrops.setDescription("The number of occasions when a RTT operation could not\nbe initiated because some necessary internal resource \n(for example memory, or SNA subsystem) was not available,\nor the operation completion could not be recognized.\n\nSince a RTT operation was never initiated or was not\nrecognized, the completion time of these operations \nare not accumulated, nor do they increment \nrttMonStatsCaptureCompletions (in the expected \nDistribution Bucket).\n\nWhen the RttMonRttType is 'pathEcho', and this error \noccurs and the rttMonStatsCapturePathIndex cannot be \ndetermined, this error will be accumulated in the \nsource to target path, that will always exist.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectSequenceErrors.setDescription("When the RttMonRttType is 'echo' of 'pathEcho' this is\nthe number of RTT operation completions received with \nan unexpected sequence identifier.  For all other values\nof RttMonRttType this object will remain zero.\n\nWhen this has occurred some of the possible reasons may\nbe:  \n   - a duplicate packet was received\n   - a response was received after it had timed-out\n   - a corrupted packet was received and was not detected\n\nThe completion time of these operations are not \naccumulated, nor do they increment \nrttMonStatsCaptureCompletions (in the expected\nDistribution Bucket).\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectVerifyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectVerifyErrors.setDescription("The number of RTT operation completions received with\ndata that does not compare with the expected data.  The \ncompletion time of these operations are not accumulated, \nnor do they increment rttMonStatsCaptureCompletions (in\nthe expected Distribution Bucket).\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 8), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectAddress.setDescription("This object only applies when the RttMonRttType is\n'echo', 'pathEcho', 'dlsw', 'udpEcho', 'tcpConnect'.  \nFor all other values of the RttMonRttType, this will be \nnull. \n\nThe object is a string which specifies the address of \nthe target for the this RTT operation.\n\nThis address will be the address of the hop along the \npath to the rttMonEchoAdminTargetAddress address, \nincluding rttMonEchoAdminTargetAddress address, or just \nthe rttMonEchoAdminTargetAddress address, when the \npath information is not collected.  This behavior is\ndefined by the rttMonCtrlAdminRttType object.\n\nThe interpretation of this string depends on the type \nof RTT operation selected, as specified by the \nrttMonEchoAdminProtocol object.")
rttMonControlEnableErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonControlEnableErrors.setDescription("The number of occasions when control enable request failed.\nCurrently it is used for multicast operation type.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.\nrttMonControlEnableErrors object is superseded by\nrttMonStatsCollectCtrlEnErrors.")
rttMonStatsRetrieveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsRetrieveErrors.setDescription("The number of occasions when stats retrieval request failed.\nCurrently it is used for multicast operation type.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.\nrttMonStatsRetrieveErrors object is superseded by\nrttMonStatsCollectRetrieveErrors.")
rttMonStatsCollectCtrlEnErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectCtrlEnErrors.setDescription("The object is same as rttMonControlEnableErrors,\nwith corrected name for consistency.\n\nThe number of occasions when control enable request failed.\nCurrently it is used for multicast operation type.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsCollectRetrieveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsCollectRetrieveErrors.setDescription("The object is same as rttMonStatsRetrieveErrors,\nwith corrected name for consistency.\n\nThe number of occasions when stats retrieval request failed.\nCurrently it is used for multicast operation type.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonStatsTotalsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3))
if mibBuilder.loadTexts: rttMonStatsTotalsTable.setDescription("The statistics totals database.\n\nThis table has the exact same behavior as the\nrttMonStatsCaptureTable, except it only keeps\n60 minute group values.\n\nFor a complete table description see\nthe rttMonStatsCaptureTable object.")
rttMonStatsTotalsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonStatsCaptureStartTimeIndex"))
if mibBuilder.loadTexts: rttMonStatsTotalsEntry.setDescription("A list of objects which accumulate the results of a\nseries of RTT operations over a 60 minute time period.\n\nThis entry has the exact same behavior as the \nrttMonStatsCaptureEntry, except it only keeps\n60 minute group values.\n\nFor a complete entry description see\nthe rttMonStatsCaptureEntry object.")
rttMonStatsTotalsElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1, 1), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsTotalsElapsedTime.setDescription("The length of time since this conceptual statistics row\nwas created.")
rttMonStatsTotalsInitiations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonStatsTotalsInitiations.setDescription("The number of RTT operations that have been initiated.\n\nThis number includes all RTT operations which succeed \nor fail for whatever reason.\n\nThis object has the special behavior as defined by the\nROLLOVER NOTE in the DESCRIPTION of the ciscoRttMonMIB\nobject.")
rttMonHTTPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4))
if mibBuilder.loadTexts: rttMonHTTPStatsTable.setDescription("The HTTP statistics collection database.\n\nThe HTTP statistics table contains summarized information of\nthe results for a conceptual RTT control row. A rolling\naccumulated history of this information is maintained in a \nseries of hourly 'group(s)'.\n\nThe operation of this table is same as that of \nrttMonStatsCaptureTable, except that this table can only \nstore a maximum of 2 hours of data.")
rttMonHTTPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHTTPStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonHTTPStatsEntry.setDescription("A list of objects which accumulate the results of a\nseries of RTT operations over a 60 minute time period.\n\nThis entry is created only if the rttMonCtrlAdminRttType \nis http. The operation of this table is same as that of\nrttMonStatsCaptureTable.")
rttMonHTTPStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 1), TimeStamp()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonHTTPStatsStartTimeIndex.setDescription("This is the time when this row was created. This index\nuniquely identifies a HTTP Stats row in the \nrttMonHTTPStatsTable.")
rttMonHTTPStatsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsCompletions.setDescription("The number of HTTP operations that have completed\nsuccessfully.")
rttMonHTTPStatsOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsOverThresholds.setDescription("The number of HTTP operations that violate threshold.")
rttMonHTTPStatsRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum.setDescription("The sum of HTTP operations that are successfully measured.")
rttMonHTTPStatsRTTSum2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2Low.setDescription("The sum of squares of the RTT's that are successfully\nmeasured (low order 32 bits).")
rttMonHTTPStatsRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTSum2High.setDescription("The sum of squares of the RTT's that are successfully\nmeasured (high order 32 bits).")
rttMonHTTPStatsRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMin.setDescription("The minimum RTT taken to perform HTTP operation.")
rttMonHTTPStatsRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsRTTMax.setDescription("The maximum RTT taken to perform HTTP operation.")
rttMonHTTPStatsDNSRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSRTTSum.setDescription("The sum of RTT taken to perform DNS query within the\nHTTP operation.")
rttMonHTTPStatsTCPConnectRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectRTTSum.setDescription("The sum of RTT taken to connect to the HTTP server.")
rttMonHTTPStatsTransactionRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionRTTSum.setDescription("The sum of RTT taken to download the object specified by URL.")
rttMonHTTPStatsMessageBodyOctetsSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsMessageBodyOctetsSum.setDescription("The sum of the size of the message body received as a\nresponse to the HTTP request.")
rttMonHTTPStatsDNSServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSServerTimeout.setDescription("The number of requests that could not connect to the\nDNS Server.")
rttMonHTTPStatsTCPConnectTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTCPConnectTimeout.setDescription("The number of requests that could not connect to the\nthe HTTP Server.")
rttMonHTTPStatsTransactionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsTransactionTimeout.setDescription("The number of requests that timed out during HTTP\ntransaction.")
rttMonHTTPStatsDNSQueryError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsDNSQueryError.setDescription("The number of requests that had DNS Query errors.")
rttMonHTTPStatsHTTPError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsHTTPError.setDescription("The number of requests that had HTTP errors while\ndownloading the base page.")
rttMonHTTPStatsError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsError.setDescription("The number of occasions when a HTTP operation could not\nbe initiated because an internal error")
rttMonHTTPStatsBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHTTPStatsBusies.setDescription("The number of occasions when an HTTP operation could not\nbe initiated because a previous HTTP operation has not\nbeen completed.")
rttMonJitterStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5))
if mibBuilder.loadTexts: rttMonJitterStatsTable.setDescription("The Jitter statistics collection database.\n\nThe Jitter statistics table contains summarized information of\nthe results for a conceptual RTT control row. A rolling\naccumulated history of this information is maintained in a \nseries of hourly 'group(s)'.\n\nThe operation of this table is same as that of \nrttMonStatsCaptureTable, except that this table will store \n2 hours of data.")
rttMonJitterStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonJitterStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonJitterStatsEntry.setDescription("A list of objects which accumulate the results of a\nseries of RTT operations over a 60 minute time period.\n\nThis entry is created only if the rttMonCtrlAdminRttType \nis jitter. The operation of this table is same as that of\nrttMonStatsCaptureTable.")
rttMonJitterStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 1), TimeStamp()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonJitterStatsStartTimeIndex.setDescription("The time when this row was created.")
rttMonJitterStatsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsCompletions.setDescription("The number of jitter operation that have completed\nsuccessfully.")
rttMonJitterStatsOverThresholds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOverThresholds.setDescription("The number of jitter operations that violate threshold.")
rttMonJitterStatsNumOfRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfRTT.setDescription("The number of RTT's that are successfully measured.")
rttMonJitterStatsRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum.setDescription("The sum of RTT's that are successfully measured (low order 32\nbits). The high order 32 bits are stored in\nrttMonJitterStatsRTTSumHigh.")
rttMonJitterStatsRTTSum2Low = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2Low.setDescription("The sum of squares of RTT's that are successfully measured\n(low order 32 bits).")
rttMonJitterStatsRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSum2High.setDescription("The sum of squares of RTT's that are successfully measured\n(high order 32 bits).")
rttMonJitterStatsRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTMin.setDescription("The minimum of RTT's that were successfully measured")
rttMonJitterStatsRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTMax.setDescription("The maximum of RTT's that were successfully measured")
rttMonJitterStatsMinOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesSD.setDescription("The minimum of absolute values of all positive jitter values\nfrom packets sent from source to destination.")
rttMonJitterStatsMaxOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesSD.setDescription("The maximum of absolute values of all positive jitter values\nfrom packets sent from source to destination.")
rttMonJitterStatsNumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesSD.setDescription("The sum of number of all positive jitter values from packets\nsent from source to destination.")
rttMonJitterStatsSumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesSD.setDescription("The sum of all positive jitter values from packets\nsent from source to destination.")
rttMonJitterStatsSum2PositivesSDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDLow.setDescription("The sum of square of RTT's of all positive jitter values from\npackets sent from source to destination (low order 32 bits).")
rttMonJitterStatsSum2PositivesSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesSDHigh.setDescription("The sum of square of RTT's of all positive jitter values from\npackets sent from source to destination (high order 32 bits).")
rttMonJitterStatsMinOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesSD.setDescription("The minimum of all negative jitter values from packets sent\nfrom source to destination.")
rttMonJitterStatsMaxOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesSD.setDescription("The maximum of all negative jitter values from packets sent\nfrom source to destination.")
rttMonJitterStatsNumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesSD.setDescription("The sum of number of all negative jitter values from packets\nsent from source to destination.")
rttMonJitterStatsSumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesSD.setDescription("The sum of RTT's of all negative jitter values from packets\nsent from source to destination.")
rttMonJitterStatsSum2NegativesSDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDLow.setDescription("The sum of square of RTT's of all negative jitter values from\npackets sent from source to destination (low order 32 bits).")
rttMonJitterStatsSum2NegativesSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesSDHigh.setDescription("The sum of square of RTT's of all negative jitter values from\npackets sent from source to destination (high order 32 bits).")
rttMonJitterStatsMinOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfPositivesDS.setDescription("The minimum of all positive jitter values from packets sent\nfrom destination to source.")
rttMonJitterStatsMaxOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfPositivesDS.setDescription("The maximum of all positive jitter values from packets sent\nfrom destination to source.")
rttMonJitterStatsNumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfPositivesDS.setDescription("The sum of number of all positive jitter values from packets\nsent from destination to source.")
rttMonJitterStatsSumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfPositivesDS.setDescription("The sum of RTT's of all positive jitter values from packets\nsent from destination to source.")
rttMonJitterStatsSum2PositivesDSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSLow.setDescription("The sum of squares of RTT's of all positive jitter values from\npackets sent from destination to source (low order 32 bits).")
rttMonJitterStatsSum2PositivesDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2PositivesDSHigh.setDescription("The sum of squares of RTT's of all positive jitter values from\npackets sent from destination to source (high order 32 bits).")
rttMonJitterStatsMinOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfNegativesDS.setDescription("The minimum of all negative jitter values from packets sent\nfrom destination to source.")
rttMonJitterStatsMaxOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfNegativesDS.setDescription("The maximum of all negative jitter values from packets sent\nfrom destination to source.")
rttMonJitterStatsNumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfNegativesDS.setDescription("The sum of number of all negative jitter values from packets\nsent from destination to source.")
rttMonJitterStatsSumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSumOfNegativesDS.setDescription("The sum of RTT's of all negative jitter values from packets\nsent from destination to source.")
rttMonJitterStatsSum2NegativesDSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSLow.setDescription("The sum of squares of RTT's of all negative jitter values from\npackets sent from destination to source (low order 32 bits).")
rttMonJitterStatsSum2NegativesDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsSum2NegativesDSHigh.setDescription("The sum of squares of RTT's of all negative jitter values from\npackets sent from destination to source (high order 32 bits).")
rttMonJitterStatsPacketLossSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossSD.setDescription("The number of packets lost when sent from source to\ndestination.")
rttMonJitterStatsPacketLossDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLossDS.setDescription("The number of packets lost when sent from destination to\nsource.")
rttMonJitterStatsPacketOutOfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketOutOfSequence.setDescription("The number of packets arrived out of sequence.")
rttMonJitterStatsPacketMIA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketMIA.setDescription("The number of packets that are lost for which we cannot\ndetermine the direction.")
rttMonJitterStatsPacketLateArrival = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsPacketLateArrival.setDescription("The number of packets that arrived after the timeout.")
rttMonJitterStatsError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsError.setDescription("The number of occasions when a jitter operation could not\nbe initiated because an internal error")
rttMonJitterStatsBusies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsBusies.setDescription("The number of occasions when a jitter operation could not\nbe initiated because a previous jitter operation has not\nbeen completed.")
rttMonJitterStatsOWSumSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSD.setDescription("The sum of one way times from source to destination (low order\n32 bits). The high order 32 bits are stored in\nrttMonJitterStatsOWSumSDHigh.")
rttMonJitterStatsOWSum2SDLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDLow.setDescription("The sum of squares of one way times from source to destination\n(low order 32 bits).")
rttMonJitterStatsOWSum2SDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2SDHigh.setDescription("The sum of squares of one way times from source to destination\n(high order 32 bits).")
rttMonJitterStatsOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSD.setDescription("The minimum of all one way times from source to destination.\nrttMonJitterStatsOWMinSD object is superseded by\nrttMonJitterStatsOWMinSDNew.")
rttMonJitterStatsOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSD.setDescription("The maximum of all one way times from source to destination.\nrttMonJitterStatsOWMaxSD object is superseded by\nrttMonJitterStatsOWMaxSDNew.")
rttMonJitterStatsOWSumDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDS.setDescription("The sum of one way times from destination to source (low order\n32 bits). The high order 32 bits are stored in\nrttMonJitterStatsOWSumDSHigh.")
rttMonJitterStatsOWSum2DSLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSLow.setDescription("The sum of squares of one way times from destination to source\n(low order 32 bits).")
rttMonJitterStatsOWSum2DSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSum2DSHigh.setDescription("The sum of squares of one way times from destination to source\n(high order 32 bits).")
rttMonJitterStatsOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDS.setDescription("The minimum of all one way times from destination to source.\nrttMonJitterStatsOWMinDS object is superseded by\nrttMonJitterStatsOWMinDSNew.")
rttMonJitterStatsOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDS.setDescription("The maximum of all one way times from destination to source.\nrttMonJitterStatsOWMaxDS object is superseded by\nrttMonJitterStatsOWMaxDSNew.")
rttMonJitterStatsNumOfOW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsNumOfOW.setDescription("The number of one way times that are successfully measured.")
rttMonJitterStatsOWMinSDNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 52), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinSDNew.setDescription("The minimum of all one way times from source to destination.\nReplaces deprecated rttMonJitterStatsOWMinSD.")
rttMonJitterStatsOWMaxSDNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxSDNew.setDescription("The maximum of all one way times from source to destination.\nReplaces deprecated rttMonJitterStatsOWMaxSD.")
rttMonJitterStatsOWMinDSNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMinDSNew.setDescription("The minimum of all one way times from destination to source.\nReplaces deprecated rttMonJitterStatsOWMinDS.")
rttMonJitterStatsOWMaxDSNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWMaxDSNew.setDescription("The maximum of all one way times from destination to source.\nReplaces deprecated rttMonJitterStatsOWMaxDS")
rttMonJitterStatsMinOfMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 56), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(100,500),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfMOS.setDescription("The minimum of all MOS values for the jitter operations\nin hundreds. \nThis value will be 0 if \n - rttMonEchoAdminCodecType of the operation is notApplicable \n - the operation is not started \n - the operation is started but failed\nThis value will be 1 for packet loss of 10% or more.")
rttMonJitterStatsMaxOfMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 57), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(100,500),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfMOS.setDescription("The maximum of all MOS values for the jitter operations\nin hunderds. \nThis value will be 0 if \n - rttMonEchoAdminCodecType of the operation is notApplicable \n - the operation is not started \n - the operation is started but failed\nThis value will be 1 for packet loss of 10% or more.")
rttMonJitterStatsMinOfICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMinOfICPIF.setDescription("The minimum of all ICPIF values for the jitter operations.\n\nThis value will be 93 for packet loss of 10% or more.")
rttMonJitterStatsMaxOfICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsMaxOfICPIF.setDescription("The maximum of all ICPIF values for the jitter operations.\n\nThis value will be 93 for packet loss of 10% or more.")
rttMonJitterStatsIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 60), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsIAJOut.setDescription("Interarrival Jitter (RFC 1889) at responder")
rttMonJitterStatsIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 61), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsIAJIn.setDescription("Interarrival Jitter (RFC 1889) at sender")
rttMonJitterStatsAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 62), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitter.setDescription("The average of positive and negative jitter\nvalues for SD and DS direction.")
rttMonJitterStatsAvgJitterSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 63), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterSD.setDescription("The average of positive and negative jitter\nvalues in SD direction.")
rttMonJitterStatsAvgJitterDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 64), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsAvgJitterDS.setDescription("The average of positive and negative jitter\nvalues in DS direction.")
rttMonJitterStatsUnSyncRTs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsUnSyncRTs.setDescription("The number of RTT operations that have completed with\nsender and responder out of sync with NTP. The NTP sync means \nthe total of NTP offset on sender and responder is within \nconfigured tolerance level.")
rttMonJitterStatsRTTSumHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsRTTSumHigh.setDescription("The sum of RTT's that are successfully measured\n(high order 32 bits). The low order 32 bits are \nstored in rttMonJitterStatsRTTSum.")
rttMonJitterStatsOWSumSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumSDHigh.setDescription("The sum of one way times from source to destination\n(high order 32 bits). The low order 32 bits are \nstored in rttMonJitterStatsOWSumSD.")
rttMonJitterStatsOWSumDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 5, 1, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonJitterStatsOWSumDSHigh.setDescription("The sum of one way times from destination to source\n(high order 32 bits). The low order 32 bits are stored\nin rttMonJitterStatsOWSumDS.")
rttMonLpdGrpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7))
if mibBuilder.loadTexts: rttMonLpdGrpStatsTable.setDescription("The Auto SAA L3 MPLS VPN LPD Group Database.\n\nThe LPD Group statistics table contains summarized performance\nstatistics for the LPD group.\n\nLPD Group - The set of 'single probes' which are subset of the\n'lspGroup' probe traversing set of paths between two PE end\npoints are grouped together and called as the LPD group. The\nLPD group will be uniquely referenced by the LPD Group ID.\n\nA rolling accumulated history of this information is maintained\nin a series of hourly 'group(s)'.\n\nEach conceptual statistics row has a current hourly group, into\nwhich RTT results are accumulated. At the end of each hour a new\nhourly group is created which then becomes current. The\ncounters and accumulators in the new group are initialized to\nzero. The previous group(s) is kept in the table until the table\ncontains rttMplsVpnMonTypeLpdStatHours groups for the\nconceptual statistics row;  at this point, the oldest group is\ndiscarded and is replaced by the newly created one. The hourly\ngroup is uniquely identified by the\nrttMonLpdGrpStatsStartTimeIndex object.")
rttMonLpdGrpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupIndex"), (0, "CISCO-RTTMON-MIB", "rttMonLpdGrpStatsStartTimeIndex"))
if mibBuilder.loadTexts: rttMonLpdGrpStatsEntry.setDescription("A list of objects which accumulate the results of a set of RTT\noperations over a 60 minute time period.\n\nThe LPD group statistics table is a rollover table. When\nrttMonLpdGrpStatsStartTimeIndex groups exceeds the\nrttMplsVpnMonTypeLpdStatHours value, the oldest corresponding\nhourly group will be deleted and will be replaced with the new\nrttMonLpdGrpStatsStartTimeIndex hourly group.\n\nThe LPD group statistics table has two indices. Each described\nas follows:\n\n- The first index correlates its entries to a LPD group via the\n   rttMonLpdGrpStatsGroupIndex object.\n- The second index is a rollover group and it uniquely \n   identifies a 60 minute group. (The \n   rttMonLpdGrpStatsStartTimeIndex is used to make this value \n   unique.)")
rttMonLpdGrpStatsGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupIndex.setDescription("Uniquely identifies a row in rttMonLpdGrpStatsTable.\n\nThis is a pseudo-random number which identifies a particular\nLPD group.")
rttMonLpdGrpStatsStartTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 2), TimeStamp()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonLpdGrpStatsStartTimeIndex.setDescription("The time when this row was created.\n\nThis object is the second index of the rttMonLpdGrpStatsTable.\nWhen the number of rttMonLpdGrpStatsStartTimeIndex groups\nexceeds the rttMplsVpnMonTypeLpdStatHours value, the oldest\nrttMonLpdGrpStatsStartTimeIndex group will be removed and\nreplaced with the new entry.")
rttMonLpdGrpStatsTargetPE = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 3), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsTargetPE.setDescription("The object is a string that specifies the address of the\ntarget PE for this LPD group.")
rttMonLpdGrpStatsNumOfPass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfPass.setDescription("This object represents the number of successfull completions\nof 'single probes' for all the set of paths in the LPD group.\n\nWhenever the rttMonLatestRttOperSense value is 'ok' for a\nparticular probe in the LPD Group this object will be\nincremented.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsNumOfFail = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfFail.setDescription("This object represents the number of failed operations of\n'single probes' for all the set of paths in the LPD group.\n\nWhenever the rttMonLatestRttOperSense has a value other than\n'ok' or 'timeout' for a particular probe in the LPD Group this\nobject will be incremented.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsNumOfTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsNumOfTimeout.setDescription("This object represents the number of timed out operations of\n'single probes' for all the set of paths in the LPD group.\n\nWhenever the rttMonLatestRttOperSense has a value of 'timeout'\nfor a particular probe in the LPD Group this object will be\nincremented.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsAvgRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsAvgRTT.setDescription("The average RTT across all set of probes in the LPD group.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsMinRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinRTT.setDescription("The minimum of RTT's for all set of probes in the LPD group\nthat were successfully measured.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsMaxRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxRTT.setDescription("The maximum of RTT's for all set of probes in the LPD group\nthat were successfully measured.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsMinNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMinNumPaths.setDescription("The minimum number of active paths discovered to the\nrttMonLpdGrpStatsTargetPE target.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsMaxNumPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsMaxNumPaths.setDescription("The maximum number of active paths discovered to the\nrttMonLpdGrpStatsTargetPE target.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsLPDStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDStartTime.setDescription("The time when the last LSP Path Discovery to the group was\nattempted.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsLPDFailOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailOccurred.setDescription("This object is set to true when the LSP Path Discovery\nto the target PE i.e. rttMonLpdGrpStatsTargetPE fails, and\nset to false when the LSP Path Discovery succeeds.\n\nWhen this value changes and rttMplsVpnMonReactLpdNotifyType is\nset to 'lpdPathDiscovery' or 'lpdAll' a\nrttMonLpdDiscoveryNotification will be generated.\n\nThis object will be set to 'FALSE' on reset.")
rttMonLpdGrpStatsLPDFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 14), RttMplsVpnMonLpdFailureSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDFailCause.setDescription("This object identifies the cause of failure for the LSP Path\nDiscovery last attempted. It will be only valid if\nrttMonLpdGrpStatsLPDFailOccurred is set to true.\n\nThis object will be set to 'unknown' on reset.")
rttMonLpdGrpStatsLPDCompTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsLPDCompTime.setDescription("The completion time of the last successfull LSP Path Discovery\nto the target PE.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 16), RttMplsVpnMonLpdGrpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupStatus.setDescription("This object identifies the LPD Group status.\n\nWhen the LPD Group status changes and\nrttMplsVpnMonReactLpdNotifyType is set to 'lpdGroupStatus' or\n'lpdAll' a rttMonLpdGrpStatusNotification will be generated.\n\nWhen the LPD Group status value is 'unknown' or changes to\n'unknown' this notification will not be generated.\n\nWhen LSP Path Discovery is enabled for a particular row in\nrttMplsVpnMonCtrlTable, 'single probes' in the 'lspGroup' probe\ncannot generate notifications independently but will be\ngenerating depending on the state of the group. Notifications \nare only generated if the failure/restoration of an individual\nprobe causes the state of the LPD Group to change.\n\nThis object will be set to 'unknown' on reset.")
rttMonLpdGrpStatsGroupProbeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsGroupProbeIndex.setDescription("This object identifies 'lspGroup' probe uniquely created for\nthis particular LPD Group.")
rttMonLpdGrpStatsPathIds = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsPathIds.setDescription("A string which holds the list of information to uniquely\nidentify the paths to the target PE. This information is used\nby the 'single probes' when testing the paths.\n\nFollowing three parameters are needed to uniquely identify a \npath\n  - lsp-selector (127.x.x.x)\n  - outgoing-interface (i/f)\n  - label-stack (s), if mutiple labels they will be colon (:)\n    separated.\n\nThese parameters will be hyphen (-) separated for a particular\npath. This set of information will be comma (,) separated for\nall the paths discovered as part of this LPD Group.\n\nFor example: If there are 5 paths in the LPD group then this\nobject will return all the identifier's to uniquely identify\nthe path.\n\nThe output will look like '127.0.0.1-Se3/0.1-20:18,\n127.0.0.2-Se3/0.1-20,127.0.0.3-Se3/0.1-20,127.0.0.4-Se3/0.1-20,\n127.0.0.5-Se3/0.1-20'.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsProbeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsProbeStatus.setDescription("A string which holds the latest operation return code for\nall the set of 'single probes' which are part of the LPD group.\nThe return codes will be comma separated and will follow the\nsame sequence of probes as followed in\n'rttMonLpdGrpStatsPathIds'. The latest operation return code\nwill be mapped to 'up','down' or 'unkwown'.\n\n'up' - Probe state is up when the rttMonLatestRttOperSense\nvalue is 'ok'.\n'down' - Probe state is down when the rttMonLatestRttOperSense\nhas value other then 'ok' and 'other'.\n'unknown' - Probe state is unkown when the\nrttMonLatestRttOperSense value is 'other'.\n\nFor example: If there are 5 paths in the LPD group then this\nobject output will look like 'ok,ok,ok,down,down'.\n\nThis object will be set to '0' on reset.")
rttMonLpdGrpStatsResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 3, 7, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLpdGrpStatsResetTime.setDescription("This object specifies the time when this statistics row was\nlast reset using the rttMonApplLpdGrpStatsReset object.")
rttMonHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4))
rttMonHistoryCollectionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1))
if mibBuilder.loadTexts: rttMonHistoryCollectionTable.setDescription("The history collection database.\n\nThe history table contains a point by point rolling \nhistory of the most recent RTT operations for each \nconceptual RTT control row.  The rolling history of this \ninformation is maintained in a series of 'live(s)', each\ncontaining a series of 'bucket(s)', each 'bucket' \ncontains a series of 'sample(s)'.\n\nEach conceptual history row can have lives.  A life is \ndefined by the rttMonCtrlOperRttLife object.  A new life \nwill be created when rttMonCtrlOperState transitions\n'active'.  When the number of lives become greater \nthan rttMonHistoryAdminNumLives the oldest life will be \ndiscarded and a new life will be created by incrementing\nthe index.\n\nThe path exploration RTT operation will be kept as an\nentry in this table.")
rttMonHistoryCollectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionLifeIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionBucketIndex"), (0, "CISCO-RTTMON-MIB", "rttMonHistoryCollectionSampleIndex"))
if mibBuilder.loadTexts: rttMonHistoryCollectionEntry.setDescription("A list of history objects that are recorded for each\nRTT operation.\n\nThe history collection table has four indices.  Each \ndescribed as follows:\n  -  The first index correlates its entries to a \n      conceptual RTT control row via the \n      rttMonCtrlAdminIndex object.  \n  -  The second index uniquely identifies the results \n      of each 'life' as defined by the \n      rttMonCtrlOperRttLife object.  \n  -  The third index uniquely identifies the number of \n      buckets in a life.  A bucket will contain one \n      sample per bucket if the rttMonCtrlAdminRttType \n      object is set to any value\n      other than 'pathEcho'.  If the \n      rttMonCtrlAdminRttType object is set to \n      'pathEcho', a bucket will contain one sample per \n      hop along a path to the target (including the \n      target).  \n  -  The fourth index uniquely identifies the number of \n      samples in a bucket.   Again, if the \n      rttMonCtrlAdminRttType object is set to \n      'pathEcho', this value is associated with each \n      hop in an ascending order, thus for the \n      first hop on a path, this index will be 1, the \n      second will be 2 and so on.   For all other values\n      of rttMonCtrlAdminRttType this will be 1.")
rttMonHistoryCollectionLifeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonHistoryCollectionLifeIndex.setDescription("This uniquely defines a life for a conceptual history\nrow.\n\nFor a particular value of rttMonHistoryCollectionLifeIndex,\nthe agent assigns the first value of 1, the second value \nof 2, and so on.  The sequence keeps incrementing, \ndespite older (lower) values being removed from the \ntable.")
rttMonHistoryCollectionBucketIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonHistoryCollectionBucketIndex.setDescription("When the RttMonRttType is 'pathEcho', this uniquely\ndefines a bucket for a given value of \nrttMonHistoryCollectionLifeIndex.  For all other \nRttMonRttType this value will be the number of\noperations per a lifetime.  Thus, this object \nincrements on each operation attempt.\n\nFor a particular value of \nrttMonHistoryCollectionLifeIndex, the agent assigns \nthe first value of 1, the second value of 2, and so \non.  The sequence keeps incrementing until the number\nof buckets equals rttMonHistoryAdminNumBuckets, after\nwhich the most recent rttMonHistoryAdminNumBuckets \nbuckets are retained (the index is incremented though).")
rttMonHistoryCollectionSampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleIndex.setDescription("This uniquely defines a row for a given value of\nrttMonHistoryCollectionBucketIndex.  This object\nrepresents a hop along a path to the Target.\n\nFor a particular value of \nrttMonHistoryCollectionBucketIndex, the agent assigns \nthe first value of 1, the second value of 2, and so on.\nThe sequence keeps incrementing until the number of \nsamples equals rttMonHistoryAdminNumSamples, then no \nnew samples are created for the current \nrttMonHistoryCollectionBucketIndex.\n\nWhen the RttMonRttType is 'pathEcho', this value \ndirectly represents the number of hops along a \npath to a target, thus we can only support 512 hops.\nFor all other values of RttMonRttType this object\nwill be one.")
rttMonHistoryCollectionSampleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSampleTime.setDescription("The time that the RTT operation was initiated.")
rttMonHistoryCollectionAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 5), RttMonTargetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionAddress.setDescription("When the RttMonRttType is 'echo' or 'pathEcho' this\nis a string which specifies the address of the target for\nthe this RTT operation.  For all other values of\nRttMonRttType this string will be null.\n\nThis address will be the address of the hop along the\npath to the rttMonEchoAdminTargetAddress address,\nincluding rttMonEchoAdminTargetAddress address, or just\nthe rttMonEchoAdminTargetAddress address, when the\npath information is not collected.  This behavior is\ndefined by the rttMonCtrlAdminRttType object.\n\nThe interpretation of this string depends on the type\nof RTT operation selected, as specified by the\nrttMonEchoAdminProtocol object.\n\nSee rttMonEchoAdminTargetAddress for a complete\ndescription.")
rttMonHistoryCollectionCompletionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionCompletionTime.setDescription("This is the operation completion time of the RTT\noperation.  If the RTT operation fails \n(rttMonHistoryCollectionSense is any \nvalue other than ok), this has a value of 0.")
rttMonHistoryCollectionSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 7), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSense.setDescription("A sense code for the completion status of the RTT\noperation.")
rttMonHistoryCollectionApplSpecificSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionApplSpecificSense.setDescription("An application specific sense code for the\ncompletion status of the last RTT operation.  This \nobject will only be valid when the \nrttMonHistoryCollectionSense object is set to \n'applicationSpecific'.  Otherwise, this object's \nvalue is not valid.")
rttMonHistoryCollectionSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 4, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonHistoryCollectionSenseDescription.setDescription("A sense description for the completion status of\nthe last RTT operation when the \nrttMonHistoryCollectionSense object is set to \n'applicationSpecific'.")
rttMonLatestOper = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5))
rttMonLatestHTTPOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1))
if mibBuilder.loadTexts: rttMonLatestHTTPOperTable.setDescription("A table which contains the status of latest HTTP RTT\noperation.")
rttMonLatestHTTPOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonLatestHTTPOperEntry.setDescription("A list of objects that record the latest HTTP RTT\noperation. This entry is created automatically after the \nrttMonCtrlAdminEntry is created. Also the entry is \nautomatically deleted when rttMonCtrlAdminEntry is deleted.")
rttMonLatestHTTPOperRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperRTT.setDescription("Round Trip Time taken to perform HTTP operation. This value\nis the sum of DNSRTT, TCPConnectRTT and TransactionRTT.")
rttMonLatestHTTPOperDNSRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperDNSRTT.setDescription("Round Trip Time taken to perform DNS query within the\nHTTP operation. If an IP Address is specified in the URL, \nthen DNSRTT is 0.")
rttMonLatestHTTPOperTCPConnectRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperTCPConnectRTT.setDescription("Round Trip Time taken to connect to the HTTP server.")
rttMonLatestHTTPOperTransactionRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperTransactionRTT.setDescription("Round Trip Time taken to download the object specified by\nthe URL.")
rttMonLatestHTTPOperMessageBodyOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperMessageBodyOctets.setDescription("The size of the message body received as a response to\nthe HTTP request.")
rttMonLatestHTTPOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 6), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPOperSense.setDescription("An application specific sense code for the completion status\nof the latest RTT operation.")
rttMonLatestHTTPErrorSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestHTTPErrorSenseDescription.setDescription("An sense description for the completion status\nof the latest RTT operation.")
rttMonLatestJitterOperTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2))
if mibBuilder.loadTexts: rttMonLatestJitterOperTable.setDescription("A table which contains the status of latest Jitter\noperation.")
rttMonLatestJitterOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1)).setIndexNames((0, "CISCO-RTTMON-MIB", "rttMonCtrlAdminIndex"))
if mibBuilder.loadTexts: rttMonLatestJitterOperEntry.setDescription("A list of objects that record the latest Jitter\noperation.")
rttMonLatestJitterOperNumOfRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfRTT.setDescription("The number of RTT's that were successfully measured.")
rttMonLatestJitterOperRTTSum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum.setDescription("The sum of Jitter RTT's that are successfully measured (low\norder 32 bits). The high order 32 bits are stored in\nrttMonLatestJitterOperRTTSumHigh.")
rttMonLatestJitterOperRTTSum2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2.setDescription("The sum of squares of RTT's that are successfully measured (low\norder 32 bits). The high order 32 bits are stored in\nrttMonLatestJitterOperRTTSum2High.")
rttMonLatestJitterOperRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMin.setDescription("The minimum of RTT's that were successfully measured.")
rttMonLatestJitterOperRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTMax.setDescription("The maximum of RTT's that were successfully measured.")
rttMonLatestJitterOperMinOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesSD.setDescription("The minimum of all positive jitter values from packets sent\nfrom source to destination.")
rttMonLatestJitterOperMaxOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesSD.setDescription("The maximum of all positive jitter values from packets sent\nfrom source to destination.")
rttMonLatestJitterOperNumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesSD.setDescription("The sum of all positive jitter values from packets\nsent from source to destination.")
rttMonLatestJitterOperSumOfPositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesSD.setDescription("The sum of RTT's of all positive jitter values from packets\nsent from source to destination.")
rttMonLatestJitterOperSum2PositivesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesSD.setDescription("The sum of square of RTT's of all positive jitter values from\npackets sent from source to destination.")
rttMonLatestJitterOperMinOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesSD.setDescription("The minimum of absolute values of all negative jitter values\nfrom packets sent from source to destination.")
rttMonLatestJitterOperMaxOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesSD.setDescription("The maximum of absolute values of all negative jitter values\nfrom packets sent from source to destination.")
rttMonLatestJitterOperNumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesSD.setDescription("The sum of number of all negative jitter values from packets\nsent from source to destination.")
rttMonLatestJitterOperSumOfNegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesSD.setDescription("The sum of all negative jitter values from packets\nsent from source to destination.")
rttMonLatestJitterOperSum2NegativesSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesSD.setDescription("The sum of square of RTT's of all negative jitter values from\npackets sent from source to destination.")
rttMonLatestJitterOperMinOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfPositivesDS.setDescription("The minimum of all positive jitter values from packets sent\nfrom destination to source.")
rttMonLatestJitterOperMaxOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfPositivesDS.setDescription("The maximum of all positive jitter values from packets sent\nfrom destination to source.")
rttMonLatestJitterOperNumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfPositivesDS.setDescription("The sum of number of all positive jitter values from packets\nsent from destination to source.")
rttMonLatestJitterOperSumOfPositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfPositivesDS.setDescription("The sum of RTT's of all positive jitter values from packets\nsent from destination to source.")
rttMonLatestJitterOperSum2PositivesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2PositivesDS.setDescription("The sum of squares of RTT's of all positive jitter values from\npackets sent from destination to source.")
rttMonLatestJitterOperMinOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMinOfNegativesDS.setDescription("The minimum of all negative jitter values from packets sent\nfrom destination to source.")
rttMonLatestJitterOperMaxOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMaxOfNegativesDS.setDescription("The maximum of all negative jitter values from packets sent\nfrom destination to source.")
rttMonLatestJitterOperNumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfNegativesDS.setDescription("The sum of number of all negative jitter values from packets\nsent from destination to source.")
rttMonLatestJitterOperSumOfNegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSumOfNegativesDS.setDescription("The sum of RTT's of all negative jitter values from packets\nsent from destination to source.")
rttMonLatestJitterOperSum2NegativesDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSum2NegativesDS.setDescription("The sum of squares of RTT's of all negative jitter values from\npackets sent from destination to source.")
rttMonLatestJitterOperPacketLossSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossSD.setDescription("The number of packets lost when sent from source to\ndestination.")
rttMonLatestJitterOperPacketLossDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLossDS.setDescription("The number of packets lost when sent from destination to\nsource.")
rttMonLatestJitterOperPacketOutOfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketOutOfSequence.setDescription("The number of packets arrived out of sequence.")
rttMonLatestJitterOperPacketMIA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketMIA.setDescription("The number of packets that are lost for which we cannot\ndetermine the direction.")
rttMonLatestJitterOperPacketLateArrival = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperPacketLateArrival.setDescription("The number of packets that arrived after the timeout.")
rttMonLatestJitterOperSense = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 31), RttResponseSense()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperSense.setDescription("An application specific sense code for the completion status\nof the latest Jitter RTT operation.")
rttMonLatestJitterErrorSenseDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 32), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterErrorSenseDescription.setDescription("An sense description for the completion status\nof the latest Jitter RTT operation.")
rttMonLatestJitterOperOWSumSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSD.setDescription("The sum of one way latency from source to destination (low\norder 32 bits). The high order 32 bits are stored in\nrttMonLatestJitterOperOWSumSDHigh.")
rttMonLatestJitterOperOWSum2SD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SD.setDescription("The sum of squares of one way latency from source to\ndestination (low order 32 bits). The high order 32 bits are\nstored in rttMonLatestJitterOperOWSum2SDHigh.")
rttMonLatestJitterOperOWMinSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinSD.setDescription("The minimum of all one way latency from source to\ndestination.")
rttMonLatestJitterOperOWMaxSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxSD.setDescription("The maximum of all one way latency from source to\ndestination.")
rttMonLatestJitterOperOWSumDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDS.setDescription("The sum of one way latency from destination to source (low\norder 32 bits). The high order 32 bits are stored in\nrttMonLatestJitterOperOWSumDSHigh.")
rttMonLatestJitterOperOWSum2DS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DS.setDescription("The sum of squares of one way latency from destination to\nsource (low order 32 bits). The high order 32 bits are stored in\nrttMonLatestJitterOperOWSum2DSHigh.")
rttMonLatestJitterOperOWMinDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMinDS.setDescription("The minimum of all one way latency from destination to\nsource.")
rttMonLatestJitterOperOWMaxDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWMaxDS.setDescription("The maximum of all one way latency from destination to\nsource.")
rttMonLatestJitterOperNumOfOW = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 41), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNumOfOW.setDescription("The number of successful one way latency measurements.")
rttMonLatestJitterOperMOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 42), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(100,500),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperMOS.setDescription("The MOS value for the latest jitter operation in hundreds.\nThis value will be 0 if \n - rttMonEchoAdminCodecType of the operation is notApplicable \n - the operation is not started \n - the operation is started but failed\nThis value will be 1 for packet loss of 10% or more.")
rttMonLatestJitterOperICPIF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 43), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperICPIF.setDescription("Represents ICPIF value for the latest jitter operation.\n\nThis value will be 93 for packet loss of 10% or more.")
rttMonLatestJitterOperIAJOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 44), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJOut.setDescription("Interarrival Jitter (RC1889) at responder.")
rttMonLatestJitterOperIAJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 45), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperIAJIn.setDescription("Interarrival Jitter (RFC1889) at source.")
rttMonLatestJitterOperAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 46), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgJitter.setDescription("The average of positive and negative jitter\nvalues in SD and DS direction for latest operation.")
rttMonLatestJitterOperAvgSDJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 47), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgSDJ.setDescription("The average of positive and negative jitter values\nfrom source to destination for latest operation.")
rttMonLatestJitterOperAvgDSJ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 48), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperAvgDSJ.setDescription("The average of positive and negative jitter values\nfrom destination to source for latest operation.")
rttMonLatestJitterOperOWAvgSD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 49), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgSD.setDescription("The average latency value from source to destination.")
rttMonLatestJitterOperOWAvgDS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 50), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWAvgDS.setDescription("The average latency value from destination to source.")
rttMonLatestJitterOperNTPState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 51), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("sync", 1), ("outOfSync", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperNTPState.setDescription("A value of sync(1) means sender and responder was in sync\nwith NTP. The NTP sync means the total of NTP offset \non sender and responder is within configured tolerance level.")
rttMonLatestJitterOperUnSyncRTs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperUnSyncRTs.setDescription("The number of RTT operations that have completed with\nsender and responder out of sync with NTP. The NTP sync means \nthe total of NTP offset on sender and responder is within \nconfigured tolerance level.")
rttMonLatestJitterOperRTTSumHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSumHigh.setDescription("The sum of Jitter RTT's that are successfully measured.\n(high order 32 bits). The low order 32 bits are stored\nin rttMonLatestJitterOperRTTSum.")
rttMonLatestJitterOperRTTSum2High = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperRTTSum2High.setDescription("The sum of squares of RTT's that are successfully measured\n(high order 32 bits). The low order 32 bits are stored in\nrttMonLatestJitterOperRTTSum2.")
rttMonLatestJitterOperOWSumSDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumSDHigh.setDescription("The sum of one way latency from source to destination\n(high order 32 bits). The low order 32 bits are stored in\nrttMonLatestJitterOperOWSumSD.")
rttMonLatestJitterOperOWSum2SDHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 56), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2SDHigh.setDescription("The sum of squares of one way latency from source to\ndestination (high order 32 bits). The low order 32 bits\nare stored in rttMonLatestJitterOperOWSum2SD.")
rttMonLatestJitterOperOWSumDSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 57), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSumDSHigh.setDescription("The sum of one way latency from destination to source\n(high order 32 bits). The low order 32 bits are stored \nin rttMonLatestJitterOperOWSumDS.")
rttMonLatestJitterOperOWSum2DSHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 42, 1, 5, 2, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rttMonLatestJitterOperOWSum2DSHigh.setDescription("The sum of squares of one way latency from destination to\nsource (high order 32 bits). The low order 32 bits are\nstored in rttMonLatestJitterOperOWSum2DS.")
rttMonNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 2))
rttMonNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0))
ciscoRttMonMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3))
ciscoRttMonMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1))
ciscoRttMonMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2))

# Augmentions
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonStatisticsAdminEntry"))
rttMonStatisticsAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMonReactTriggerAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonReactTriggerOperEntry"))
rttMonReactTriggerOperEntry.setIndexNames(*rttMonReactTriggerAdminEntry.getIndexNames())
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonReactEntry"))
rttMplsVpnMonReactEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonLatestRttOperEntry"))
rttMonLatestRttOperEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonCtrlOperEntry"))
rttMonCtrlOperEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonHistoryAdminEntry"))
rttMonHistoryAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleEntry"))
rttMplsVpnMonScheduleEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonScheduleAdminEntry"))
rttMonScheduleAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMonCtrlAdminEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMonReactAdminEntry"))
rttMonReactAdminEntry.setIndexNames(*rttMonCtrlAdminEntry.getIndexNames())
rttMplsVpnMonCtrlEntry.registerAugmentions(("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeEntry"))
rttMplsVpnMonTypeEntry.setIndexNames(*rttMplsVpnMonCtrlEntry.getIndexNames())

# Notifications

rttMonConnectionChangeNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 1)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ) )
if mibBuilder.loadTexts: rttMonConnectionChangeNotification.setDescription("This notification is only valid when the RttMonRttType\nis 'echo' or 'pathEcho'.\n\nA rttMonConnectionChangeNotification indicates that a\nconnection to a target (not to a hop along the path\nto a target) has either failed on establishment or \nbeen lost and when reestablished.  Precisely, this\nhas resulted in rttMonCtrlOperConnectionLostOccurred\nchanging value.\n\nIf History is not being collected, the instance values \nfor the rttMonHistoryCollectionAddress object will not \nbe valid.  When RttMonRttType is not 'echo' or 'pathEcho'\nthe rttMonHistoryCollectionAddress object will be null.\nrttMonConnectionChangeNotification object is superseded by\nrttMonNotification.")
rttMonTimeoutNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 2)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ) )
if mibBuilder.loadTexts: rttMonTimeoutNotification.setDescription("A rttMonTimeoutNotification indicates the occurrence of\na timeout for a RTT operation, and it indicates the \nclearing of such a condition by a subsequent RTT \noperation. Precisely, this has resulted in \nrttMonCtrlOperTimeoutOccurred changing value. \n\nWhen the RttMonRttType is 'pathEcho', this \nnotification will only be sent when the timeout \noccurs during an operation to the target and not to\na hop along the path to the target.  This also \napplies to the clearing of the timeout. \n\nIf History is not being collected, the instance values \nfor the rttMonHistoryCollectionAddress object will not \nbe valid.  When RttMonRttType is not 'echo' or 'pathEcho'\nthe rttMonHistoryCollectionAddress object will be null.\nrttMonTimeoutNotification object is superseded by\nrttMonNotification.")
rttMonThresholdNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 3)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ) )
if mibBuilder.loadTexts: rttMonThresholdNotification.setDescription("A rttMonThresholdNotification indicates the\noccurrence of a threshold violation for a RTT operation,\nand it indicates the previous violation has subsided for\na subsequent RTT operation.  Precisely, this has resulted\nin rttMonCtrlOperOverThresholdOccurred changing value.  \n\nWhen the RttMonRttType is 'pathEcho', this \nnotification will only be sent when the threshold\nviolation occurs during an operation to the target and\nnot to a hop along the path to the target.  This also\napplies to the subsiding of a threshold condition.\n\nIf History is not being collected, the instance values \nfor the rttMonHistoryCollectionAddress object will not \nbe valid.  When RttMonRttType is not 'echo' or 'pathEcho'\nthe rttMonHistoryCollectionAddress object will be null.\n\nrttMonThresholdNotification object is superseded by\nrttMonNotification.")
rttMonVerifyErrorNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 4)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"), ) )
if mibBuilder.loadTexts: rttMonVerifyErrorNotification.setDescription("A rttMonVerifyErrorNotification indicates the\noccurrence of a data corruption in an RTT operation.\nrttMonVerifyErrorNotification object is superseded by\nrttMonNotification.")
rttMonNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 5)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonReactValue"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonReactVar"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonReactOccurred"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdRising"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPSelector"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ) )
if mibBuilder.loadTexts: rttMonNotification.setDescription("A rttMonNotification indicates the occurrence of a\nthreshold violation, and it indicates the previous\nviolation has subsided for a subsequent operation. \n\nWhen the RttMonRttType is 'pathEcho', this\nnotification will only be sent when the threshold\nviolation occurs during an operation to the target and\nnot to a hop along the path to the target. This also\napplies to the subsiding of a threshold condition.\n\nIf History is not being collected, the instance values\nfor the rttMonHistoryCollectionAddress object will not\nbe valid. When RttMonRttType is not 'echo' or 'pathEcho'\nthe rttMonHistoryCollectionAddress object will be null.\n\nrttMonReactVar defines the type of reaction that is\nconfigured for the probe ( e.g jitterAvg, rtt etc ).\nIn the rttMonReactTable there are trap definitions\nfor the probes and each probe may have more than\none trap definitions for various types ( e.g rtt,\njitterAvg, packetLoossSD etc ). So the object rttMonReactVar\nindicates the type ( e.g. rtt, packetLossSD, timeout etc )\nfor which threshold violation traps has been generated.\n\nThe object rttMonEchoAdminLSPSelector will be valid only\nfor the probes based on 'mplsLspPingAppl' RttMonProtocol. For\nall other probes it will be null.")
rttMonLpdDiscoveryNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 6)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailCause"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailOccurred"), ) )
if mibBuilder.loadTexts: rttMonLpdDiscoveryNotification.setDescription("A rttMonLpdDiscoveryNotification indicates that the LSP Path\nDiscovery to the target PE has failed, and it also indicates\nthe clearing of such condition. Precisely this has resulted in\nrttMonLpdGrpStatsLPDFailOccurred changing value.\n\nWhen the rttMonLpdGrpStatsLPDFailOccurred is 'false', the\ninstance value for rttMonLpdGrpStatsLPDFailCause is not valid.")
rttMonLpdGrpStatusNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 42, 2, 0, 7)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupStatus"), ) )
if mibBuilder.loadTexts: rttMonLpdGrpStatusNotification.setDescription("A rttMonLpdGrpStatusNotification indicates that the LPD\nGroup status rttMonLpdGrpStatsGroupStatus has changed indicating\nsome connectivity change to the target PE.\nThis has resulted in rttMonLpdGrpStatsGroupStatus changing\nvalue.")

# Groups

ciscoStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 3)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletionTimeMax"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectAddress"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime2High"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectNumDisconnects"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectSequenceErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectBusies"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureOverThresholds"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectNoConnections"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletions"), ("CISCO-RTTMON-MIB", "rttMonStatsTotalsElapsedTime"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectVerifyErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectTimeouts"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureSumCompletionTime2Low"), ("CISCO-RTTMON-MIB", "rttMonStatsTotalsInitiations"), ("CISCO-RTTMON-MIB", "rttMonStatsCaptureCompletionTimeMin"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectDrops"), ) )
if mibBuilder.loadTexts: ciscoStatsGroup.setDescription("A collection of objects providing accumulated statistical\nhistory.")
ciscoHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 4)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonHistoryCollectionCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSampleTime"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionAddress"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonHistoryCollectionSense"), ) )
if mibBuilder.loadTexts: ciscoHistoryGroup.setDescription("A collection of objects providing point by point\nhistory of each RTT operation.")
ciscoCtrlGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 5)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTOS"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetPort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlEnable"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSREnable"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourcePort"), ("CISCO-RTTMON-MIB", "rttMonEchoPathAdminHopAddress"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev1.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application.")
ciscoCtrlGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 6)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminURL"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminNameServer"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProxy"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminHTTPVersion"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminNumPackets"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminMode"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOperation"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddressString"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCache"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString3"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString2"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString1"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString5"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminString4"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev2.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application to configure HTTP, DNS and \nJitter probes.")
ciscoLatestOperGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 7)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketOutOfSequence"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLossSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTMin"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperMessageBodyOctets"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2PositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperTCPConnectRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketMIA"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTMax"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2NegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperTransactionRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2PositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLateArrival"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperPacketLossDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSum2NegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSense"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMaxOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum2"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPErrorSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestHTTPOperDNSRTT"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterErrorSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperSumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMinOfNegativesDS"), ) )
if mibBuilder.loadTexts: ciscoLatestOperGroupRev1.setDescription("A collection of objects that were added to store the latest\noperational results for HTTP, DNS and Jitter probes.")
ciscoStatsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 8)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesDSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketOutOfSequence"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsOverThresholds"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesSDLow"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSServerTimeout"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum2Low"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsBusies"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLateArrival"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSQueryError"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsBusies"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTCPConnectRTTSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsCompletions"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTransactionRTTSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2PositivesDSLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketMIA"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLossDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfRTT"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsCompletions"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesDSLow"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsHTTPError"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTMin"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTMax"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsError"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTMin"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesSDLow"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTransactionTimeout"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsMessageBodyOctetsSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSum2NegativesDSHigh"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsDNSRTTSum"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTMax"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsError"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfNegativesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfPositivesDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfNegativesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsSumOfPositivesSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsPacketLossSD"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsRTTSum2Low"), ("CISCO-RTTMON-MIB", "rttMonHTTPStatsTCPConnectTimeout"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOverThresholds"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev1.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application to store 'HTTP' and \n'Jitter' probes statistics.")
ciscoApplGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 11)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonApplAuthStatus"), ("CISCO-RTTMON-MIB", "rttMonApplResponder"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString3"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString2"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString1"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyChain"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString5"), ("CISCO-RTTMON-MIB", "rttMonApplAuthKeyString4"), ) )
if mibBuilder.loadTexts: ciscoApplGroupRev2.setDescription("These objects provide support for configuring responder\non a router and also configure authentication information.")
ciscoCtrlGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 12)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminVrfName"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev4.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application.")
ciscoStatsGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 14)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsNumOfOW"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxDSNew"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMinDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMaxSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2DSLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinSDNew"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxSDNew"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2SD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNumOfOW"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2DSHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMinSD"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2SDLow"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWMaxDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSum2SDHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2DS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinDSNew"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev3.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application to store one way\n'Jitter' probes statistics.")
ciscoCtrlGroupRev6 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 16)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecType"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecNumPackets"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminICPIFAdvFactor"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCodecPayload"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev6.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application.")
ciscoStatsGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 17)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfMOS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfMOS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMinOfICPIF"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsMaxOfICPIF"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperMOS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperICPIF"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev4.setDescription("A collection of objects that were added to enhance the\nfunctionality of the RTT application to store MOS and \nICPIF for 'Jitter' probe statistics.")
ciscoNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 18)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonTimeoutNotification"), ("CISCO-RTTMON-MIB", "rttMonConnectionChangeNotification"), ("CISCO-RTTMON-MIB", "rttMonThresholdNotification"), ("CISCO-RTTMON-MIB", "rttMonVerifyErrorNotification"), ) )
if mibBuilder.loadTexts: ciscoNotificationGroup.setDescription("A collection of notifications.\nciscoNotificationGroup object is superseded by\nciscoNotificationGroupRev1.")
ciscoApplGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 19)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonApplVersion"), ("CISCO-RTTMON-MIB", "rttMonApplFreeMemLowWaterMark"), ("CISCO-RTTMON-MIB", "rttMonApplMaxPacketDataSize"), ("CISCO-RTTMON-MIB", "rttMonApplSupportedProtocolsValid"), ("CISCO-RTTMON-MIB", "rttMonApplTimeOfLastSet"), ("CISCO-RTTMON-MIB", "rttMonApplProbeCapacity"), ("CISCO-RTTMON-MIB", "rttMonApplNumCtrlAdminEntry"), ("CISCO-RTTMON-MIB", "rttMonApplSupportedRttTypesValid"), ("CISCO-RTTMON-MIB", "rttMonApplLatestSetError"), ("CISCO-RTTMON-MIB", "rttMonApplReset"), ) )
if mibBuilder.loadTexts: ciscoApplGroupRev3.setDescription("A collection of objects providing the RTT Monitoring\nApplication defaults.\n\nThis group of information is provided to the agent when\nthe Application starts.")
ciscoCtrlGroupRev7 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 20)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminAgeout"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminPeriod"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminLife"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttRecurring"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminProbes"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStatus"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev7.setDescription("A collection of objects that were added to enhance the\nscheduling functionality of the RTT application.")
ciscoCtrlGroupRev8 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 21)).setObjects(*(("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlThreshold"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTag"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactThresholdType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlRttType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPTTL"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlVrfName"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeNumPackets"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlEXP"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlStatus"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonSchedulePeriod"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPReplyMode"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPSelector"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLspSelector"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPReplyMode"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlRequestSize"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeDestPort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPTTL"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPFECType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlScanInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlProbeList"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactTimeoutEnable"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlVerifyData"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleFrequency"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactActionType"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPExp"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlStorageType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactConnectionEnable"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonScheduleRttStartTime"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactThresholdCount"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeSecFreqType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlDelScanFactor"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeSecFreqValue"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev8.setDescription("A collection of objects that were added to support\n(1) echo operations support based on MPLS LSP Ping,\n(2) pathEcho operations support based on MPLS LSP Ping and\n(3) Auto SAA L3 MPLS VPN enhancement.")
ciscoStatsGroupRev5 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 22)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitterDS"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitter"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperUnSyncRTs"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgDSJ"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgSDJ"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsIAJOut"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperAvgJitter"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWAvgDS"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperIAJOut"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsUnSyncRTs"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsIAJIn"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsAvgJitterSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWAvgSD"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperNTPState"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperIAJIn"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev5.setDescription("A collection of objects that are added to report\nintera-rrival Jitter, average jitter and improve accuracy.")
ciscoCtrlGroupRev9 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 23)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminPrecision"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminGKRegistration"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCalledNumber"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolPct"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolAbs"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProbePakPriority"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminDetectPoint"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminOWNTPSyncTolType"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev9.setDescription("A collection of objects that are added to enhance the\njitter probe accuracy.")
ciscoCtrlGroupRev10 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 24)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonReactTriggerOperState"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperDiagText"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumPaths"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHourGroups"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataResponseSize"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTimeout"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminVerifyData"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOctetsInUse"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminNvgen"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminConceptRowAgeout"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProtocol"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminThreshold"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataRequestSize"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminDistInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHops"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumDistBuckets"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumBuckets"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperRttLife"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSense"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperState"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttStartTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminRttType"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumLives"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumSamples"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminFilter"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperNumRtts"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperModificationTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminOwner"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttLife"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperResetTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminStatus"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev10.setDescription("A collection of objects providing the Administration,\nOperational, Last Statistical values for the RTT\nMonitoring Application.\nciscoCtrlGroupRev10 object is superseded by\nciscoCtrlGroupRev28.")
ciscoCtrlGroupRev11 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 25)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonReactActionType"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdRising"), ("CISCO-RTTMON-MIB", "rttMonReactValue"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFreqMax"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdCountY"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdCountX"), ("CISCO-RTTMON-MIB", "rttMonReactStatus"), ("CISCO-RTTMON-MIB", "rttMonReactVar"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminFreqMin"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdType"), ("CISCO-RTTMON-MIB", "rttMonReactThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonReactOccurred"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev11.setDescription("A collection of objects that were added\nfor the reaction configuration of probe.")
ciscoNotificationGroupRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 26)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonNotification"), ) )
if mibBuilder.loadTexts: ciscoNotificationGroupRev1.setDescription("A collection of notifications.")
ciscoCtrlGroupRev12 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 27)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceVoicePort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminCallDuration"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev12.setDescription("A collection of objects that were added\nfor the configuration of rtp operation.")
ciscoCtrlGroupRev13 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 29)).setObjects(*(("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpdCompTime"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPReplyDscp"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdScanPeriod"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLSPReplyDscp"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoInterval"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdStatHours"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdSessTimeout"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpdGrpList"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactLpdNotifyType"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonCtrlLpd"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonReactLpdRetryCount"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdEchoNullShim"), ("CISCO-RTTMON-MIB", "rttMplsVpnMonTypeLpdMaxSessions"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPNullShim"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev13.setDescription("A collection of objects that were added\nfor the parameters configuration of mpls based operations.")
ciscoStatsGroupRev7 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 30)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMaxNumPaths"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupProbeIndex"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsProbeStatus"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsPathIds"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsGroupStatus"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsTargetPE"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsResetTime"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfTimeout"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfPass"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMaxRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailCause"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMinRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsNumOfFail"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsMinNumPaths"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsAvgRTT"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDFailOccurred"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDCompTime"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatsLPDStartTime"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev7.setDescription("A collection of objects that are added for\ncollecting the statistics for LSP Path Discovery Group.")
ciscoNotificationGroupRev2 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 31)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonLpdDiscoveryNotification"), ("CISCO-RTTMON-MIB", "rttMonLpdGrpStatusNotification"), ) )
if mibBuilder.loadTexts: ciscoNotificationGroupRev2.setDescription("A collection of notifications added for supporting LSP\nPath Discovery.")
ciscoApplGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 32)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonApplLpdGrpStatsReset"), ) )
if mibBuilder.loadTexts: ciscoApplGroupRev4.setDescription("This object is added to reset the LSP Path Discovery Stats.")
ciscoCtrlGroupRev14 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 33)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminStartTime"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminReset"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminDelete"), ("CISCO-RTTMON-MIB", "rttMonGrpScheduleAdminAdd"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev14.setDescription("This object is added for group scheduler enhancement")
ciscoCtrlGroupRev15 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 34)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminEthernetCOS"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetDomainName"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetVLAN"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMPID"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev15.setDescription("These objects are added for Ethernet ping/jitter operation.")
ciscoRttMonObsoleteGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 35)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonApplPreConfigedValid"), ("CISCO-RTTMON-MIB", "rttMonScriptAdminName"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminFilePath"), ("CISCO-RTTMON-MIB", "rttMonApplPreConfigedReset"), ("CISCO-RTTMON-MIB", "rttMonScriptAdminCmdLineParams"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminSize"), ("CISCO-RTTMON-MIB", "rttMonFileIOAdminAction"), ) )
if mibBuilder.loadTexts: ciscoRttMonObsoleteGroupRev1.setDescription("A collection of all objects that are obsolete.")
ciscoRttMonDeprecatedGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 36)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxDS"), ("CISCO-RTTMON-MIB", "rttMonReactAdminTimeoutEnable"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdCount"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdCount2"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinSD"), ("CISCO-RTTMON-MIB", "rttMonReactAdminConnectionEnable"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMaxSD"), ("CISCO-RTTMON-MIB", "rttMonReactAdminVerifyErrorEnable"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdType"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWMinDS"), ("CISCO-RTTMON-MIB", "rttMonReactAdminThresholdFalling"), ("CISCO-RTTMON-MIB", "rttMonReactAdminActionType"), ) )
if mibBuilder.loadTexts: ciscoRttMonDeprecatedGroupRev1.setDescription("A collection of all objects that are deprecated.\nciscoRttMonDeprecatedGroupRev1 object is superseded by\nciscoCtrlGroupRev11.")
ciscoCtrlGroupRev16 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 37)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminLSPVccvID"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev16.setDescription("These objects are added for LSP Ping Pseudowire operation.")
ciscoCtrlGroupRev17 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 38)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonCtrlAdminGroupName"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev17.setDescription("This object is added for IP SLA Auto Measure project.")
ciscoCtrlGroupRev18 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 39)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetEVC"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev18.setDescription("This object is added for Ethernet ping/jitter operation.")
ciscoStatsGroupRev8 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 40)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumSDHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2DSHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumSDHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsRTTSumHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSum2SDHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperOWSumDSHigh"), ("CISCO-RTTMON-MIB", "rttMonJitterStatsOWSumDSHigh"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSum2High"), ("CISCO-RTTMON-MIB", "rttMonLatestJitterOperRTTSumHigh"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev8.setDescription("A collection of objects that were added to store the high order\n32 bits of RTT and one way latency statistics for 'jitter'\nprobe.")
ciscoCtrlGroupRev19 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 41)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMEPPort"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev19.setDescription("This object is added for Ethernet ping/jitter operation.")
ciscoCtrlGroupRev20 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 43)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminVideoTrafficProfile"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev20.setDescription("This object has been added for video operation.")
ciscoCtrlGroupRev21 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 44)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminReserveDsp"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminInputInterface"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminDscp"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev21.setDescription("This object has been added to support of DSCP marking, sender\nDSP reservation, and source interface for path congruence in\nvideo operation.")
ciscoCtrlGroupRev22 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 45)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateTargetPort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateSourcePort"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEmulateSourceAddress"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev22.setDescription("This object has been added to support of emulate source\naddress, emulate source port, emulate target address and emulate\ntarget port for path congruence in video operation.")
ciscoCtrlGroupRev23 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 46)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceMPID"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSourceMacAddress"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetMacAddress"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev23.setDescription("This group contains objects describing Y1731\noperation.")
ciscoCtrlGroupRev24 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 47)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonGeneratedOperCtrlAdminIndex"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev24.setDescription("This object has been added to for Generated Oper Table.")
ciscoCtrlGroupRev25 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 48)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminEndPointListName"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminIgmpTreeInit"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlRetry"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminSSM"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminControlTimeout"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev25.setDescription("This object has been added to support Multicast operation.")
ciscoStatsGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 49)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonStatsRetrieveErrors"), ("CISCO-RTTMON-MIB", "rttMonControlEnableErrors"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev2.setDescription("A collection of objects providing Multicast control\nrequest information.\nciscoStatsGroupRev2 object is superseded by\nciscoStatsGroupRev9.")
ciscoCtrlGroupRev26 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 50)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminAggBurstCycles"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminAvailNumFrames"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminLossRatioNumFrames"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminEnableBurst"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev26.setDescription("New rttMonObjects related to the support of Y1731 Synthetic\nLoss Measurement.")
ciscoCtrlGroupRev27 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 51)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonEchoAdminTstampOptimization"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev27.setDescription("The object is added to utilize lower layer (Hardware/Packet\nProcessor) timestamping for improving accuracy of jitter probe\nstatistics.\n\nCurrently the object is supported for udp jitter operations.")
ciscoCtrlGroupRev28 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 52)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonReactTriggerOperState"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperDiagText"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumPaths"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHourGroups"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataResponseSize"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperAddress"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTimeout"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminVerifyData"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOctetsInUse"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminNvgen"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminProtocol"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminThreshold"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminPktDataRequestSize"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminDistInterval"), ("CISCO-RTTMON-MIB", "rttMonEchoAdminTargetAddress"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumHops"), ("CISCO-RTTMON-MIB", "rttMonStatisticsAdminNumDistBuckets"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumBuckets"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperRttLife"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSense"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperState"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperSenseDescription"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttStartTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminRttType"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperApplSpecificSense"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumLives"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperConnectionLostOccurred"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminNumSamples"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminTag"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminConceptRowAgeoutV2"), ("CISCO-RTTMON-MIB", "rttMonReactTriggerAdminStatus"), ("CISCO-RTTMON-MIB", "rttMonHistoryAdminFilter"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperVerifyErrorOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperOverThresholdOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperTimeoutOccurred"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperNumRtts"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperModificationTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminOwner"), ("CISCO-RTTMON-MIB", "rttMonLatestRttOperCompletionTime"), ("CISCO-RTTMON-MIB", "rttMonScheduleAdminRttLife"), ("CISCO-RTTMON-MIB", "rttMonCtrlOperResetTime"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminFrequency"), ("CISCO-RTTMON-MIB", "rttMonCtrlAdminStatus"), ) )
if mibBuilder.loadTexts: ciscoCtrlGroupRev28.setDescription("A collection of objects providing the Administration,\nOperational, Last Statistical values for the RTT\nMonitoring Application.\n\nDeprecated rttMonScheduleAdminConceptRowAgeout and added new\nrttMonScheduleAdminConceptRowAgeoutV2 to consider 0 as default\nage out value.")
ciscoStatsGroupRev9 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 2, 53)).setObjects(*(("CISCO-RTTMON-MIB", "rttMonStatsCollectCtrlEnErrors"), ("CISCO-RTTMON-MIB", "rttMonStatsCollectRetrieveErrors"), ) )
if mibBuilder.loadTexts: ciscoStatsGroupRev9.setDescription("A collection of objects providing Multicast control request\ninformation.")

# Compliances

ciscoRttMonMibComplianceRev12 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 12)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev12.setDescription("The compliance statement for new MIB extensions for\n(1) supporting LSP Path Discovery for Auto SAA L3 MPLS VPN.\n(2) Group Scheduler Enhancement.")
ciscoRttMonMibComplianceRev13 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 13)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoNotificationGroup"), ("CISCO-RTTMON-MIB", "ciscoRttMonDeprecatedGroupRev1"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev13.setDescription("The compliance statement for the deprecated groups.")
ciscoRttMonMibComplianceRev14 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 14)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev14.setDescription("The compliance statement for new MIB extensions for\n(1) supporting LSP Path Discovery for Auto SAA L3 MPLS VPN.\n(2) Group Scheduler Enhancement.")
ciscoRttMonMibComplianceRev15 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 15)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev15.setDescription("The compliance statement for new MIB extensions for\nsupporting Ethernet CFM for Virtual Connection.")
ciscoRttMonMibComplianceRev16 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 16)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev16.setDescription("The compliance statement for new MIB extensions for\nsupporting high order 32 bit of RTT and OW statistics\nfor jitter probe.")
ciscoRttMonMibComplianceRev17 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 17)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev17.setDescription("The compliance statement for new MIB extensions for\nsupporting high order 32 bit of RTT and OW statistics\nfor jitter probe.")
ciscoRttMonMibComplianceRev18 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 18)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev18.setDescription("The compliance statement for new MIB extensions for\nsupporting high order 32 bit of RTT and OW statistics\nfor jitter probe.")
ciscoRttMonMibComplianceRev19 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 19)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev19.setDescription("The compliance statement for new MIB extensions for\nsupporting high order 32 bit of RTT and OW statistics\nfor jitter probe.")
ciscoRttMonMibComplianceRev20 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 20)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev10"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev20.setDescription("This compliance statement specifies the minimal\nrequirements an implementation must meet in order to \nclaim full compliance with the definition of the CISCO-\nRTTMON-MIB.")
ciscoRttMonMibComplianceRev21 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 42, 3, 1, 21)).setObjects(*(("CISCO-RTTMON-MIB", "ciscoApplGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev20"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoApplGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoLatestOperGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoHistoryGroup"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev5"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev3"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoNotificationGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoStatsGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev1"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev2"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev28"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev4"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev6"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev7"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev8"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev9"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev21"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev27"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev23"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev22"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev18"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev19"), ("CISCO-RTTMON-MIB", "ciscoStatsGroup"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev26"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev25"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev24"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev12"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev13"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev11"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev16"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev17"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev14"), ("CISCO-RTTMON-MIB", "ciscoCtrlGroupRev15"), ) )
if mibBuilder.loadTexts: ciscoRttMonMibComplianceRev21.setDescription("Please enter description here")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", PYSNMP_MODULE_ID=ciscoRttMonMIB)

# Objects
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", ciscoRttMonMIB=ciscoRttMonMIB, ciscoRttMonObjects=ciscoRttMonObjects, rttMonAppl=rttMonAppl, rttMonApplVersion=rttMonApplVersion, rttMonApplMaxPacketDataSize=rttMonApplMaxPacketDataSize, rttMonApplTimeOfLastSet=rttMonApplTimeOfLastSet, rttMonApplNumCtrlAdminEntry=rttMonApplNumCtrlAdminEntry, rttMonApplReset=rttMonApplReset, rttMonApplPreConfigedReset=rttMonApplPreConfigedReset, rttMonApplSupportedRttTypesTable=rttMonApplSupportedRttTypesTable, rttMonApplSupportedRttTypesEntry=rttMonApplSupportedRttTypesEntry, rttMonApplSupportedRttTypes=rttMonApplSupportedRttTypes, rttMonApplSupportedRttTypesValid=rttMonApplSupportedRttTypesValid, rttMonApplSupportedProtocolsTable=rttMonApplSupportedProtocolsTable, rttMonApplSupportedProtocolsEntry=rttMonApplSupportedProtocolsEntry, rttMonApplSupportedProtocols=rttMonApplSupportedProtocols, rttMonApplSupportedProtocolsValid=rttMonApplSupportedProtocolsValid, rttMonApplPreConfigedTable=rttMonApplPreConfigedTable, rttMonApplPreConfigedEntry=rttMonApplPreConfigedEntry, rttMonApplPreConfigedType=rttMonApplPreConfigedType, rttMonApplPreConfigedName=rttMonApplPreConfigedName, rttMonApplPreConfigedValid=rttMonApplPreConfigedValid, rttMonApplProbeCapacity=rttMonApplProbeCapacity, rttMonApplFreeMemLowWaterMark=rttMonApplFreeMemLowWaterMark, rttMonApplLatestSetError=rttMonApplLatestSetError, rttMonApplResponder=rttMonApplResponder, rttMonApplAuthTable=rttMonApplAuthTable, rttMonApplAuthEntry=rttMonApplAuthEntry, rttMonApplAuthIndex=rttMonApplAuthIndex, rttMonApplAuthKeyChain=rttMonApplAuthKeyChain, rttMonApplAuthKeyString1=rttMonApplAuthKeyString1, rttMonApplAuthKeyString2=rttMonApplAuthKeyString2, rttMonApplAuthKeyString3=rttMonApplAuthKeyString3, rttMonApplAuthKeyString4=rttMonApplAuthKeyString4, rttMonApplAuthKeyString5=rttMonApplAuthKeyString5, rttMonApplAuthStatus=rttMonApplAuthStatus, rttMonApplLpdGrpStatsReset=rttMonApplLpdGrpStatsReset, rttMonCtrl=rttMonCtrl, rttMonCtrlAdminTable=rttMonCtrlAdminTable, rttMonCtrlAdminEntry=rttMonCtrlAdminEntry, rttMonCtrlAdminIndex=rttMonCtrlAdminIndex, rttMonCtrlAdminOwner=rttMonCtrlAdminOwner, rttMonCtrlAdminTag=rttMonCtrlAdminTag, rttMonCtrlAdminRttType=rttMonCtrlAdminRttType, rttMonCtrlAdminThreshold=rttMonCtrlAdminThreshold, rttMonCtrlAdminFrequency=rttMonCtrlAdminFrequency, rttMonCtrlAdminTimeout=rttMonCtrlAdminTimeout, rttMonCtrlAdminVerifyData=rttMonCtrlAdminVerifyData, rttMonCtrlAdminStatus=rttMonCtrlAdminStatus, rttMonCtrlAdminNvgen=rttMonCtrlAdminNvgen, rttMonCtrlAdminGroupName=rttMonCtrlAdminGroupName, rttMonEchoAdminTable=rttMonEchoAdminTable, rttMonEchoAdminEntry=rttMonEchoAdminEntry, rttMonEchoAdminProtocol=rttMonEchoAdminProtocol, rttMonEchoAdminTargetAddress=rttMonEchoAdminTargetAddress, rttMonEchoAdminPktDataRequestSize=rttMonEchoAdminPktDataRequestSize, rttMonEchoAdminPktDataResponseSize=rttMonEchoAdminPktDataResponseSize, rttMonEchoAdminTargetPort=rttMonEchoAdminTargetPort, rttMonEchoAdminSourceAddress=rttMonEchoAdminSourceAddress, rttMonEchoAdminSourcePort=rttMonEchoAdminSourcePort, rttMonEchoAdminControlEnable=rttMonEchoAdminControlEnable, rttMonEchoAdminTOS=rttMonEchoAdminTOS, rttMonEchoAdminLSREnable=rttMonEchoAdminLSREnable, rttMonEchoAdminTargetAddressString=rttMonEchoAdminTargetAddressString, rttMonEchoAdminNameServer=rttMonEchoAdminNameServer, rttMonEchoAdminOperation=rttMonEchoAdminOperation, rttMonEchoAdminHTTPVersion=rttMonEchoAdminHTTPVersion, rttMonEchoAdminURL=rttMonEchoAdminURL, rttMonEchoAdminCache=rttMonEchoAdminCache, rttMonEchoAdminInterval=rttMonEchoAdminInterval, rttMonEchoAdminNumPackets=rttMonEchoAdminNumPackets, rttMonEchoAdminProxy=rttMonEchoAdminProxy, rttMonEchoAdminString1=rttMonEchoAdminString1, rttMonEchoAdminString2=rttMonEchoAdminString2, rttMonEchoAdminString3=rttMonEchoAdminString3, rttMonEchoAdminString4=rttMonEchoAdminString4, rttMonEchoAdminString5=rttMonEchoAdminString5, rttMonEchoAdminMode=rttMonEchoAdminMode, rttMonEchoAdminVrfName=rttMonEchoAdminVrfName, rttMonEchoAdminCodecType=rttMonEchoAdminCodecType, rttMonEchoAdminCodecInterval=rttMonEchoAdminCodecInterval, rttMonEchoAdminCodecPayload=rttMonEchoAdminCodecPayload, rttMonEchoAdminCodecNumPackets=rttMonEchoAdminCodecNumPackets, rttMonEchoAdminICPIFAdvFactor=rttMonEchoAdminICPIFAdvFactor, rttMonEchoAdminLSPFECType=rttMonEchoAdminLSPFECType, rttMonEchoAdminLSPSelector=rttMonEchoAdminLSPSelector, rttMonEchoAdminLSPReplyMode=rttMonEchoAdminLSPReplyMode, rttMonEchoAdminLSPTTL=rttMonEchoAdminLSPTTL, rttMonEchoAdminLSPExp=rttMonEchoAdminLSPExp, rttMonEchoAdminPrecision=rttMonEchoAdminPrecision, rttMonEchoAdminProbePakPriority=rttMonEchoAdminProbePakPriority, rttMonEchoAdminOWNTPSyncTolAbs=rttMonEchoAdminOWNTPSyncTolAbs, rttMonEchoAdminOWNTPSyncTolPct=rttMonEchoAdminOWNTPSyncTolPct, rttMonEchoAdminOWNTPSyncTolType=rttMonEchoAdminOWNTPSyncTolType, rttMonEchoAdminCalledNumber=rttMonEchoAdminCalledNumber, rttMonEchoAdminDetectPoint=rttMonEchoAdminDetectPoint, rttMonEchoAdminGKRegistration=rttMonEchoAdminGKRegistration, rttMonEchoAdminSourceVoicePort=rttMonEchoAdminSourceVoicePort, rttMonEchoAdminCallDuration=rttMonEchoAdminCallDuration, rttMonEchoAdminLSPReplyDscp=rttMonEchoAdminLSPReplyDscp, rttMonEchoAdminLSPNullShim=rttMonEchoAdminLSPNullShim, rttMonEchoAdminTargetMPID=rttMonEchoAdminTargetMPID, rttMonEchoAdminTargetDomainName=rttMonEchoAdminTargetDomainName, rttMonEchoAdminTargetVLAN=rttMonEchoAdminTargetVLAN, rttMonEchoAdminEthernetCOS=rttMonEchoAdminEthernetCOS, rttMonEchoAdminLSPVccvID=rttMonEchoAdminLSPVccvID, rttMonEchoAdminTargetEVC=rttMonEchoAdminTargetEVC, rttMonEchoAdminTargetMEPPort=rttMonEchoAdminTargetMEPPort, rttMonEchoAdminVideoTrafficProfile=rttMonEchoAdminVideoTrafficProfile, rttMonEchoAdminDscp=rttMonEchoAdminDscp, rttMonEchoAdminReserveDsp=rttMonEchoAdminReserveDsp, rttMonEchoAdminInputInterface=rttMonEchoAdminInputInterface, rttMonEchoAdminEmulateSourceAddress=rttMonEchoAdminEmulateSourceAddress, rttMonEchoAdminEmulateSourcePort=rttMonEchoAdminEmulateSourcePort, rttMonEchoAdminEmulateTargetAddress=rttMonEchoAdminEmulateTargetAddress, rttMonEchoAdminEmulateTargetPort=rttMonEchoAdminEmulateTargetPort, rttMonEchoAdminTargetMacAddress=rttMonEchoAdminTargetMacAddress, rttMonEchoAdminSourceMacAddress=rttMonEchoAdminSourceMacAddress, rttMonEchoAdminSourceMPID=rttMonEchoAdminSourceMPID, rttMonEchoAdminEndPointListName=rttMonEchoAdminEndPointListName, rttMonEchoAdminSSM=rttMonEchoAdminSSM, rttMonEchoAdminControlRetry=rttMonEchoAdminControlRetry, rttMonEchoAdminControlTimeout=rttMonEchoAdminControlTimeout, rttMonEchoAdminIgmpTreeInit=rttMonEchoAdminIgmpTreeInit, rttMonEchoAdminEnableBurst=rttMonEchoAdminEnableBurst, rttMonEchoAdminAggBurstCycles=rttMonEchoAdminAggBurstCycles)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonEchoAdminLossRatioNumFrames=rttMonEchoAdminLossRatioNumFrames, rttMonEchoAdminAvailNumFrames=rttMonEchoAdminAvailNumFrames, rttMonEchoAdminTstampOptimization=rttMonEchoAdminTstampOptimization, rttMonFileIOAdminTable=rttMonFileIOAdminTable, rttMonFileIOAdminEntry=rttMonFileIOAdminEntry, rttMonFileIOAdminFilePath=rttMonFileIOAdminFilePath, rttMonFileIOAdminSize=rttMonFileIOAdminSize, rttMonFileIOAdminAction=rttMonFileIOAdminAction, rttMonScriptAdminTable=rttMonScriptAdminTable, rttMonScriptAdminEntry=rttMonScriptAdminEntry, rttMonScriptAdminName=rttMonScriptAdminName, rttMonScriptAdminCmdLineParams=rttMonScriptAdminCmdLineParams, rttMonScheduleAdminTable=rttMonScheduleAdminTable, rttMonScheduleAdminEntry=rttMonScheduleAdminEntry, rttMonScheduleAdminRttLife=rttMonScheduleAdminRttLife, rttMonScheduleAdminRttStartTime=rttMonScheduleAdminRttStartTime, rttMonScheduleAdminConceptRowAgeout=rttMonScheduleAdminConceptRowAgeout, rttMonScheduleAdminRttRecurring=rttMonScheduleAdminRttRecurring, rttMonScheduleAdminConceptRowAgeoutV2=rttMonScheduleAdminConceptRowAgeoutV2, rttMonReactAdminTable=rttMonReactAdminTable, rttMonReactAdminEntry=rttMonReactAdminEntry, rttMonReactAdminConnectionEnable=rttMonReactAdminConnectionEnable, rttMonReactAdminTimeoutEnable=rttMonReactAdminTimeoutEnable, rttMonReactAdminThresholdType=rttMonReactAdminThresholdType, rttMonReactAdminThresholdFalling=rttMonReactAdminThresholdFalling, rttMonReactAdminThresholdCount=rttMonReactAdminThresholdCount, rttMonReactAdminThresholdCount2=rttMonReactAdminThresholdCount2, rttMonReactAdminActionType=rttMonReactAdminActionType, rttMonReactAdminVerifyErrorEnable=rttMonReactAdminVerifyErrorEnable, rttMonStatisticsAdminTable=rttMonStatisticsAdminTable, rttMonStatisticsAdminEntry=rttMonStatisticsAdminEntry, rttMonStatisticsAdminNumHourGroups=rttMonStatisticsAdminNumHourGroups, rttMonStatisticsAdminNumPaths=rttMonStatisticsAdminNumPaths, rttMonStatisticsAdminNumHops=rttMonStatisticsAdminNumHops, rttMonStatisticsAdminNumDistBuckets=rttMonStatisticsAdminNumDistBuckets, rttMonStatisticsAdminDistInterval=rttMonStatisticsAdminDistInterval, rttMonHistoryAdminTable=rttMonHistoryAdminTable, rttMonHistoryAdminEntry=rttMonHistoryAdminEntry, rttMonHistoryAdminNumLives=rttMonHistoryAdminNumLives, rttMonHistoryAdminNumBuckets=rttMonHistoryAdminNumBuckets, rttMonHistoryAdminNumSamples=rttMonHistoryAdminNumSamples, rttMonHistoryAdminFilter=rttMonHistoryAdminFilter, rttMonCtrlOperTable=rttMonCtrlOperTable, rttMonCtrlOperEntry=rttMonCtrlOperEntry, rttMonCtrlOperModificationTime=rttMonCtrlOperModificationTime, rttMonCtrlOperDiagText=rttMonCtrlOperDiagText, rttMonCtrlOperResetTime=rttMonCtrlOperResetTime, rttMonCtrlOperOctetsInUse=rttMonCtrlOperOctetsInUse, rttMonCtrlOperConnectionLostOccurred=rttMonCtrlOperConnectionLostOccurred, rttMonCtrlOperTimeoutOccurred=rttMonCtrlOperTimeoutOccurred, rttMonCtrlOperOverThresholdOccurred=rttMonCtrlOperOverThresholdOccurred, rttMonCtrlOperNumRtts=rttMonCtrlOperNumRtts, rttMonCtrlOperRttLife=rttMonCtrlOperRttLife, rttMonCtrlOperState=rttMonCtrlOperState, rttMonCtrlOperVerifyErrorOccurred=rttMonCtrlOperVerifyErrorOccurred, rttMonLatestRttOperTable=rttMonLatestRttOperTable, rttMonLatestRttOperEntry=rttMonLatestRttOperEntry, rttMonLatestRttOperCompletionTime=rttMonLatestRttOperCompletionTime, rttMonLatestRttOperSense=rttMonLatestRttOperSense, rttMonLatestRttOperApplSpecificSense=rttMonLatestRttOperApplSpecificSense, rttMonLatestRttOperSenseDescription=rttMonLatestRttOperSenseDescription, rttMonLatestRttOperTime=rttMonLatestRttOperTime, rttMonLatestRttOperAddress=rttMonLatestRttOperAddress, rttMonReactTriggerAdminTable=rttMonReactTriggerAdminTable, rttMonReactTriggerAdminEntry=rttMonReactTriggerAdminEntry, rttMonReactTriggerAdminRttMonCtrlAdminIndex=rttMonReactTriggerAdminRttMonCtrlAdminIndex, rttMonReactTriggerAdminStatus=rttMonReactTriggerAdminStatus, rttMonReactTriggerOperTable=rttMonReactTriggerOperTable, rttMonReactTriggerOperEntry=rttMonReactTriggerOperEntry, rttMonReactTriggerOperState=rttMonReactTriggerOperState, rttMonEchoPathAdminTable=rttMonEchoPathAdminTable, rttMonEchoPathAdminEntry=rttMonEchoPathAdminEntry, rttMonEchoPathAdminHopIndex=rttMonEchoPathAdminHopIndex, rttMonEchoPathAdminHopAddress=rttMonEchoPathAdminHopAddress, rttMonGrpScheduleAdminTable=rttMonGrpScheduleAdminTable, rttMonGrpScheduleAdminEntry=rttMonGrpScheduleAdminEntry, rttMonGrpScheduleAdminIndex=rttMonGrpScheduleAdminIndex, rttMonGrpScheduleAdminProbes=rttMonGrpScheduleAdminProbes, rttMonGrpScheduleAdminPeriod=rttMonGrpScheduleAdminPeriod, rttMonGrpScheduleAdminFrequency=rttMonGrpScheduleAdminFrequency, rttMonGrpScheduleAdminLife=rttMonGrpScheduleAdminLife, rttMonGrpScheduleAdminAgeout=rttMonGrpScheduleAdminAgeout, rttMonGrpScheduleAdminStatus=rttMonGrpScheduleAdminStatus, rttMonGrpScheduleAdminFreqMax=rttMonGrpScheduleAdminFreqMax, rttMonGrpScheduleAdminFreqMin=rttMonGrpScheduleAdminFreqMin, rttMonGrpScheduleAdminStartTime=rttMonGrpScheduleAdminStartTime, rttMonGrpScheduleAdminAdd=rttMonGrpScheduleAdminAdd, rttMonGrpScheduleAdminDelete=rttMonGrpScheduleAdminDelete, rttMonGrpScheduleAdminReset=rttMonGrpScheduleAdminReset, rttMplsVpnMonCtrlTable=rttMplsVpnMonCtrlTable, rttMplsVpnMonCtrlEntry=rttMplsVpnMonCtrlEntry, rttMplsVpnMonCtrlIndex=rttMplsVpnMonCtrlIndex, rttMplsVpnMonCtrlRttType=rttMplsVpnMonCtrlRttType, rttMplsVpnMonCtrlVrfName=rttMplsVpnMonCtrlVrfName, rttMplsVpnMonCtrlTag=rttMplsVpnMonCtrlTag, rttMplsVpnMonCtrlThreshold=rttMplsVpnMonCtrlThreshold, rttMplsVpnMonCtrlTimeout=rttMplsVpnMonCtrlTimeout, rttMplsVpnMonCtrlScanInterval=rttMplsVpnMonCtrlScanInterval, rttMplsVpnMonCtrlDelScanFactor=rttMplsVpnMonCtrlDelScanFactor, rttMplsVpnMonCtrlEXP=rttMplsVpnMonCtrlEXP, rttMplsVpnMonCtrlRequestSize=rttMplsVpnMonCtrlRequestSize, rttMplsVpnMonCtrlVerifyData=rttMplsVpnMonCtrlVerifyData, rttMplsVpnMonCtrlStorageType=rttMplsVpnMonCtrlStorageType, rttMplsVpnMonCtrlProbeList=rttMplsVpnMonCtrlProbeList, rttMplsVpnMonCtrlStatus=rttMplsVpnMonCtrlStatus, rttMplsVpnMonCtrlLpd=rttMplsVpnMonCtrlLpd, rttMplsVpnMonCtrlLpdGrpList=rttMplsVpnMonCtrlLpdGrpList, rttMplsVpnMonCtrlLpdCompTime=rttMplsVpnMonCtrlLpdCompTime, rttMplsVpnMonTypeTable=rttMplsVpnMonTypeTable, rttMplsVpnMonTypeEntry=rttMplsVpnMonTypeEntry, rttMplsVpnMonTypeInterval=rttMplsVpnMonTypeInterval, rttMplsVpnMonTypeNumPackets=rttMplsVpnMonTypeNumPackets, rttMplsVpnMonTypeDestPort=rttMplsVpnMonTypeDestPort, rttMplsVpnMonTypeSecFreqType=rttMplsVpnMonTypeSecFreqType, rttMplsVpnMonTypeSecFreqValue=rttMplsVpnMonTypeSecFreqValue, rttMplsVpnMonTypeLspSelector=rttMplsVpnMonTypeLspSelector, rttMplsVpnMonTypeLSPReplyMode=rttMplsVpnMonTypeLSPReplyMode, rttMplsVpnMonTypeLSPTTL=rttMplsVpnMonTypeLSPTTL, rttMplsVpnMonTypeLSPReplyDscp=rttMplsVpnMonTypeLSPReplyDscp, rttMplsVpnMonTypeLpdMaxSessions=rttMplsVpnMonTypeLpdMaxSessions, rttMplsVpnMonTypeLpdSessTimeout=rttMplsVpnMonTypeLpdSessTimeout, rttMplsVpnMonTypeLpdEchoTimeout=rttMplsVpnMonTypeLpdEchoTimeout, rttMplsVpnMonTypeLpdEchoInterval=rttMplsVpnMonTypeLpdEchoInterval, rttMplsVpnMonTypeLpdEchoNullShim=rttMplsVpnMonTypeLpdEchoNullShim, rttMplsVpnMonTypeLpdScanPeriod=rttMplsVpnMonTypeLpdScanPeriod, rttMplsVpnMonTypeLpdStatHours=rttMplsVpnMonTypeLpdStatHours, rttMplsVpnMonScheduleTable=rttMplsVpnMonScheduleTable)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMplsVpnMonScheduleEntry=rttMplsVpnMonScheduleEntry, rttMplsVpnMonScheduleRttStartTime=rttMplsVpnMonScheduleRttStartTime, rttMplsVpnMonSchedulePeriod=rttMplsVpnMonSchedulePeriod, rttMplsVpnMonScheduleFrequency=rttMplsVpnMonScheduleFrequency, rttMplsVpnMonReactTable=rttMplsVpnMonReactTable, rttMplsVpnMonReactEntry=rttMplsVpnMonReactEntry, rttMplsVpnMonReactConnectionEnable=rttMplsVpnMonReactConnectionEnable, rttMplsVpnMonReactTimeoutEnable=rttMplsVpnMonReactTimeoutEnable, rttMplsVpnMonReactThresholdType=rttMplsVpnMonReactThresholdType, rttMplsVpnMonReactThresholdCount=rttMplsVpnMonReactThresholdCount, rttMplsVpnMonReactActionType=rttMplsVpnMonReactActionType, rttMplsVpnMonReactLpdNotifyType=rttMplsVpnMonReactLpdNotifyType, rttMplsVpnMonReactLpdRetryCount=rttMplsVpnMonReactLpdRetryCount, rttMonReactTable=rttMonReactTable, rttMonReactEntry=rttMonReactEntry, rttMonReactConfigIndex=rttMonReactConfigIndex, rttMonReactVar=rttMonReactVar, rttMonReactThresholdType=rttMonReactThresholdType, rttMonReactActionType=rttMonReactActionType, rttMonReactThresholdRising=rttMonReactThresholdRising, rttMonReactThresholdFalling=rttMonReactThresholdFalling, rttMonReactThresholdCountX=rttMonReactThresholdCountX, rttMonReactThresholdCountY=rttMonReactThresholdCountY, rttMonReactValue=rttMonReactValue, rttMonReactOccurred=rttMonReactOccurred, rttMonReactStatus=rttMonReactStatus, rttMonGeneratedOperTable=rttMonGeneratedOperTable, rttMonGeneratedOperEntry=rttMonGeneratedOperEntry, rttMonGeneratedOperRespIpAddrType=rttMonGeneratedOperRespIpAddrType, rttMonGeneratedOperRespIpAddr=rttMonGeneratedOperRespIpAddr, rttMonGeneratedOperCtrlAdminIndex=rttMonGeneratedOperCtrlAdminIndex, rttMonStats=rttMonStats, rttMonStatsCaptureTable=rttMonStatsCaptureTable, rttMonStatsCaptureEntry=rttMonStatsCaptureEntry, rttMonStatsCaptureStartTimeIndex=rttMonStatsCaptureStartTimeIndex, rttMonStatsCapturePathIndex=rttMonStatsCapturePathIndex, rttMonStatsCaptureHopIndex=rttMonStatsCaptureHopIndex, rttMonStatsCaptureDistIndex=rttMonStatsCaptureDistIndex, rttMonStatsCaptureCompletions=rttMonStatsCaptureCompletions, rttMonStatsCaptureOverThresholds=rttMonStatsCaptureOverThresholds, rttMonStatsCaptureSumCompletionTime=rttMonStatsCaptureSumCompletionTime, rttMonStatsCaptureSumCompletionTime2Low=rttMonStatsCaptureSumCompletionTime2Low, rttMonStatsCaptureSumCompletionTime2High=rttMonStatsCaptureSumCompletionTime2High, rttMonStatsCaptureCompletionTimeMax=rttMonStatsCaptureCompletionTimeMax, rttMonStatsCaptureCompletionTimeMin=rttMonStatsCaptureCompletionTimeMin, rttMonStatsCollectTable=rttMonStatsCollectTable, rttMonStatsCollectEntry=rttMonStatsCollectEntry, rttMonStatsCollectNumDisconnects=rttMonStatsCollectNumDisconnects, rttMonStatsCollectTimeouts=rttMonStatsCollectTimeouts, rttMonStatsCollectBusies=rttMonStatsCollectBusies, rttMonStatsCollectNoConnections=rttMonStatsCollectNoConnections, rttMonStatsCollectDrops=rttMonStatsCollectDrops, rttMonStatsCollectSequenceErrors=rttMonStatsCollectSequenceErrors, rttMonStatsCollectVerifyErrors=rttMonStatsCollectVerifyErrors, rttMonStatsCollectAddress=rttMonStatsCollectAddress, rttMonControlEnableErrors=rttMonControlEnableErrors, rttMonStatsRetrieveErrors=rttMonStatsRetrieveErrors, rttMonStatsCollectCtrlEnErrors=rttMonStatsCollectCtrlEnErrors, rttMonStatsCollectRetrieveErrors=rttMonStatsCollectRetrieveErrors, rttMonStatsTotalsTable=rttMonStatsTotalsTable, rttMonStatsTotalsEntry=rttMonStatsTotalsEntry, rttMonStatsTotalsElapsedTime=rttMonStatsTotalsElapsedTime, rttMonStatsTotalsInitiations=rttMonStatsTotalsInitiations, rttMonHTTPStatsTable=rttMonHTTPStatsTable, rttMonHTTPStatsEntry=rttMonHTTPStatsEntry, rttMonHTTPStatsStartTimeIndex=rttMonHTTPStatsStartTimeIndex, rttMonHTTPStatsCompletions=rttMonHTTPStatsCompletions, rttMonHTTPStatsOverThresholds=rttMonHTTPStatsOverThresholds, rttMonHTTPStatsRTTSum=rttMonHTTPStatsRTTSum, rttMonHTTPStatsRTTSum2Low=rttMonHTTPStatsRTTSum2Low, rttMonHTTPStatsRTTSum2High=rttMonHTTPStatsRTTSum2High, rttMonHTTPStatsRTTMin=rttMonHTTPStatsRTTMin, rttMonHTTPStatsRTTMax=rttMonHTTPStatsRTTMax, rttMonHTTPStatsDNSRTTSum=rttMonHTTPStatsDNSRTTSum, rttMonHTTPStatsTCPConnectRTTSum=rttMonHTTPStatsTCPConnectRTTSum, rttMonHTTPStatsTransactionRTTSum=rttMonHTTPStatsTransactionRTTSum, rttMonHTTPStatsMessageBodyOctetsSum=rttMonHTTPStatsMessageBodyOctetsSum, rttMonHTTPStatsDNSServerTimeout=rttMonHTTPStatsDNSServerTimeout, rttMonHTTPStatsTCPConnectTimeout=rttMonHTTPStatsTCPConnectTimeout, rttMonHTTPStatsTransactionTimeout=rttMonHTTPStatsTransactionTimeout, rttMonHTTPStatsDNSQueryError=rttMonHTTPStatsDNSQueryError, rttMonHTTPStatsHTTPError=rttMonHTTPStatsHTTPError, rttMonHTTPStatsError=rttMonHTTPStatsError, rttMonHTTPStatsBusies=rttMonHTTPStatsBusies, rttMonJitterStatsTable=rttMonJitterStatsTable, rttMonJitterStatsEntry=rttMonJitterStatsEntry, rttMonJitterStatsStartTimeIndex=rttMonJitterStatsStartTimeIndex, rttMonJitterStatsCompletions=rttMonJitterStatsCompletions, rttMonJitterStatsOverThresholds=rttMonJitterStatsOverThresholds, rttMonJitterStatsNumOfRTT=rttMonJitterStatsNumOfRTT, rttMonJitterStatsRTTSum=rttMonJitterStatsRTTSum, rttMonJitterStatsRTTSum2Low=rttMonJitterStatsRTTSum2Low, rttMonJitterStatsRTTSum2High=rttMonJitterStatsRTTSum2High, rttMonJitterStatsRTTMin=rttMonJitterStatsRTTMin, rttMonJitterStatsRTTMax=rttMonJitterStatsRTTMax, rttMonJitterStatsMinOfPositivesSD=rttMonJitterStatsMinOfPositivesSD, rttMonJitterStatsMaxOfPositivesSD=rttMonJitterStatsMaxOfPositivesSD, rttMonJitterStatsNumOfPositivesSD=rttMonJitterStatsNumOfPositivesSD, rttMonJitterStatsSumOfPositivesSD=rttMonJitterStatsSumOfPositivesSD, rttMonJitterStatsSum2PositivesSDLow=rttMonJitterStatsSum2PositivesSDLow, rttMonJitterStatsSum2PositivesSDHigh=rttMonJitterStatsSum2PositivesSDHigh, rttMonJitterStatsMinOfNegativesSD=rttMonJitterStatsMinOfNegativesSD, rttMonJitterStatsMaxOfNegativesSD=rttMonJitterStatsMaxOfNegativesSD, rttMonJitterStatsNumOfNegativesSD=rttMonJitterStatsNumOfNegativesSD, rttMonJitterStatsSumOfNegativesSD=rttMonJitterStatsSumOfNegativesSD, rttMonJitterStatsSum2NegativesSDLow=rttMonJitterStatsSum2NegativesSDLow, rttMonJitterStatsSum2NegativesSDHigh=rttMonJitterStatsSum2NegativesSDHigh, rttMonJitterStatsMinOfPositivesDS=rttMonJitterStatsMinOfPositivesDS, rttMonJitterStatsMaxOfPositivesDS=rttMonJitterStatsMaxOfPositivesDS, rttMonJitterStatsNumOfPositivesDS=rttMonJitterStatsNumOfPositivesDS, rttMonJitterStatsSumOfPositivesDS=rttMonJitterStatsSumOfPositivesDS, rttMonJitterStatsSum2PositivesDSLow=rttMonJitterStatsSum2PositivesDSLow, rttMonJitterStatsSum2PositivesDSHigh=rttMonJitterStatsSum2PositivesDSHigh, rttMonJitterStatsMinOfNegativesDS=rttMonJitterStatsMinOfNegativesDS, rttMonJitterStatsMaxOfNegativesDS=rttMonJitterStatsMaxOfNegativesDS, rttMonJitterStatsNumOfNegativesDS=rttMonJitterStatsNumOfNegativesDS, rttMonJitterStatsSumOfNegativesDS=rttMonJitterStatsSumOfNegativesDS, rttMonJitterStatsSum2NegativesDSLow=rttMonJitterStatsSum2NegativesDSLow, rttMonJitterStatsSum2NegativesDSHigh=rttMonJitterStatsSum2NegativesDSHigh, rttMonJitterStatsPacketLossSD=rttMonJitterStatsPacketLossSD, rttMonJitterStatsPacketLossDS=rttMonJitterStatsPacketLossDS, rttMonJitterStatsPacketOutOfSequence=rttMonJitterStatsPacketOutOfSequence, rttMonJitterStatsPacketMIA=rttMonJitterStatsPacketMIA, rttMonJitterStatsPacketLateArrival=rttMonJitterStatsPacketLateArrival, rttMonJitterStatsError=rttMonJitterStatsError, rttMonJitterStatsBusies=rttMonJitterStatsBusies, rttMonJitterStatsOWSumSD=rttMonJitterStatsOWSumSD)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonJitterStatsOWSum2SDLow=rttMonJitterStatsOWSum2SDLow, rttMonJitterStatsOWSum2SDHigh=rttMonJitterStatsOWSum2SDHigh, rttMonJitterStatsOWMinSD=rttMonJitterStatsOWMinSD, rttMonJitterStatsOWMaxSD=rttMonJitterStatsOWMaxSD, rttMonJitterStatsOWSumDS=rttMonJitterStatsOWSumDS, rttMonJitterStatsOWSum2DSLow=rttMonJitterStatsOWSum2DSLow, rttMonJitterStatsOWSum2DSHigh=rttMonJitterStatsOWSum2DSHigh, rttMonJitterStatsOWMinDS=rttMonJitterStatsOWMinDS, rttMonJitterStatsOWMaxDS=rttMonJitterStatsOWMaxDS, rttMonJitterStatsNumOfOW=rttMonJitterStatsNumOfOW, rttMonJitterStatsOWMinSDNew=rttMonJitterStatsOWMinSDNew, rttMonJitterStatsOWMaxSDNew=rttMonJitterStatsOWMaxSDNew, rttMonJitterStatsOWMinDSNew=rttMonJitterStatsOWMinDSNew, rttMonJitterStatsOWMaxDSNew=rttMonJitterStatsOWMaxDSNew, rttMonJitterStatsMinOfMOS=rttMonJitterStatsMinOfMOS, rttMonJitterStatsMaxOfMOS=rttMonJitterStatsMaxOfMOS, rttMonJitterStatsMinOfICPIF=rttMonJitterStatsMinOfICPIF, rttMonJitterStatsMaxOfICPIF=rttMonJitterStatsMaxOfICPIF, rttMonJitterStatsIAJOut=rttMonJitterStatsIAJOut, rttMonJitterStatsIAJIn=rttMonJitterStatsIAJIn, rttMonJitterStatsAvgJitter=rttMonJitterStatsAvgJitter, rttMonJitterStatsAvgJitterSD=rttMonJitterStatsAvgJitterSD, rttMonJitterStatsAvgJitterDS=rttMonJitterStatsAvgJitterDS, rttMonJitterStatsUnSyncRTs=rttMonJitterStatsUnSyncRTs, rttMonJitterStatsRTTSumHigh=rttMonJitterStatsRTTSumHigh, rttMonJitterStatsOWSumSDHigh=rttMonJitterStatsOWSumSDHigh, rttMonJitterStatsOWSumDSHigh=rttMonJitterStatsOWSumDSHigh, rttMonLpdGrpStatsTable=rttMonLpdGrpStatsTable, rttMonLpdGrpStatsEntry=rttMonLpdGrpStatsEntry, rttMonLpdGrpStatsGroupIndex=rttMonLpdGrpStatsGroupIndex, rttMonLpdGrpStatsStartTimeIndex=rttMonLpdGrpStatsStartTimeIndex, rttMonLpdGrpStatsTargetPE=rttMonLpdGrpStatsTargetPE, rttMonLpdGrpStatsNumOfPass=rttMonLpdGrpStatsNumOfPass, rttMonLpdGrpStatsNumOfFail=rttMonLpdGrpStatsNumOfFail, rttMonLpdGrpStatsNumOfTimeout=rttMonLpdGrpStatsNumOfTimeout, rttMonLpdGrpStatsAvgRTT=rttMonLpdGrpStatsAvgRTT, rttMonLpdGrpStatsMinRTT=rttMonLpdGrpStatsMinRTT, rttMonLpdGrpStatsMaxRTT=rttMonLpdGrpStatsMaxRTT, rttMonLpdGrpStatsMinNumPaths=rttMonLpdGrpStatsMinNumPaths, rttMonLpdGrpStatsMaxNumPaths=rttMonLpdGrpStatsMaxNumPaths, rttMonLpdGrpStatsLPDStartTime=rttMonLpdGrpStatsLPDStartTime, rttMonLpdGrpStatsLPDFailOccurred=rttMonLpdGrpStatsLPDFailOccurred, rttMonLpdGrpStatsLPDFailCause=rttMonLpdGrpStatsLPDFailCause, rttMonLpdGrpStatsLPDCompTime=rttMonLpdGrpStatsLPDCompTime, rttMonLpdGrpStatsGroupStatus=rttMonLpdGrpStatsGroupStatus, rttMonLpdGrpStatsGroupProbeIndex=rttMonLpdGrpStatsGroupProbeIndex, rttMonLpdGrpStatsPathIds=rttMonLpdGrpStatsPathIds, rttMonLpdGrpStatsProbeStatus=rttMonLpdGrpStatsProbeStatus, rttMonLpdGrpStatsResetTime=rttMonLpdGrpStatsResetTime, rttMonHistory=rttMonHistory, rttMonHistoryCollectionTable=rttMonHistoryCollectionTable, rttMonHistoryCollectionEntry=rttMonHistoryCollectionEntry, rttMonHistoryCollectionLifeIndex=rttMonHistoryCollectionLifeIndex, rttMonHistoryCollectionBucketIndex=rttMonHistoryCollectionBucketIndex, rttMonHistoryCollectionSampleIndex=rttMonHistoryCollectionSampleIndex, rttMonHistoryCollectionSampleTime=rttMonHistoryCollectionSampleTime, rttMonHistoryCollectionAddress=rttMonHistoryCollectionAddress, rttMonHistoryCollectionCompletionTime=rttMonHistoryCollectionCompletionTime, rttMonHistoryCollectionSense=rttMonHistoryCollectionSense, rttMonHistoryCollectionApplSpecificSense=rttMonHistoryCollectionApplSpecificSense, rttMonHistoryCollectionSenseDescription=rttMonHistoryCollectionSenseDescription, rttMonLatestOper=rttMonLatestOper, rttMonLatestHTTPOperTable=rttMonLatestHTTPOperTable, rttMonLatestHTTPOperEntry=rttMonLatestHTTPOperEntry, rttMonLatestHTTPOperRTT=rttMonLatestHTTPOperRTT, rttMonLatestHTTPOperDNSRTT=rttMonLatestHTTPOperDNSRTT, rttMonLatestHTTPOperTCPConnectRTT=rttMonLatestHTTPOperTCPConnectRTT, rttMonLatestHTTPOperTransactionRTT=rttMonLatestHTTPOperTransactionRTT, rttMonLatestHTTPOperMessageBodyOctets=rttMonLatestHTTPOperMessageBodyOctets, rttMonLatestHTTPOperSense=rttMonLatestHTTPOperSense, rttMonLatestHTTPErrorSenseDescription=rttMonLatestHTTPErrorSenseDescription, rttMonLatestJitterOperTable=rttMonLatestJitterOperTable, rttMonLatestJitterOperEntry=rttMonLatestJitterOperEntry, rttMonLatestJitterOperNumOfRTT=rttMonLatestJitterOperNumOfRTT, rttMonLatestJitterOperRTTSum=rttMonLatestJitterOperRTTSum, rttMonLatestJitterOperRTTSum2=rttMonLatestJitterOperRTTSum2, rttMonLatestJitterOperRTTMin=rttMonLatestJitterOperRTTMin, rttMonLatestJitterOperRTTMax=rttMonLatestJitterOperRTTMax, rttMonLatestJitterOperMinOfPositivesSD=rttMonLatestJitterOperMinOfPositivesSD, rttMonLatestJitterOperMaxOfPositivesSD=rttMonLatestJitterOperMaxOfPositivesSD, rttMonLatestJitterOperNumOfPositivesSD=rttMonLatestJitterOperNumOfPositivesSD, rttMonLatestJitterOperSumOfPositivesSD=rttMonLatestJitterOperSumOfPositivesSD, rttMonLatestJitterOperSum2PositivesSD=rttMonLatestJitterOperSum2PositivesSD, rttMonLatestJitterOperMinOfNegativesSD=rttMonLatestJitterOperMinOfNegativesSD, rttMonLatestJitterOperMaxOfNegativesSD=rttMonLatestJitterOperMaxOfNegativesSD, rttMonLatestJitterOperNumOfNegativesSD=rttMonLatestJitterOperNumOfNegativesSD, rttMonLatestJitterOperSumOfNegativesSD=rttMonLatestJitterOperSumOfNegativesSD, rttMonLatestJitterOperSum2NegativesSD=rttMonLatestJitterOperSum2NegativesSD, rttMonLatestJitterOperMinOfPositivesDS=rttMonLatestJitterOperMinOfPositivesDS, rttMonLatestJitterOperMaxOfPositivesDS=rttMonLatestJitterOperMaxOfPositivesDS, rttMonLatestJitterOperNumOfPositivesDS=rttMonLatestJitterOperNumOfPositivesDS, rttMonLatestJitterOperSumOfPositivesDS=rttMonLatestJitterOperSumOfPositivesDS, rttMonLatestJitterOperSum2PositivesDS=rttMonLatestJitterOperSum2PositivesDS, rttMonLatestJitterOperMinOfNegativesDS=rttMonLatestJitterOperMinOfNegativesDS, rttMonLatestJitterOperMaxOfNegativesDS=rttMonLatestJitterOperMaxOfNegativesDS, rttMonLatestJitterOperNumOfNegativesDS=rttMonLatestJitterOperNumOfNegativesDS, rttMonLatestJitterOperSumOfNegativesDS=rttMonLatestJitterOperSumOfNegativesDS, rttMonLatestJitterOperSum2NegativesDS=rttMonLatestJitterOperSum2NegativesDS, rttMonLatestJitterOperPacketLossSD=rttMonLatestJitterOperPacketLossSD, rttMonLatestJitterOperPacketLossDS=rttMonLatestJitterOperPacketLossDS, rttMonLatestJitterOperPacketOutOfSequence=rttMonLatestJitterOperPacketOutOfSequence, rttMonLatestJitterOperPacketMIA=rttMonLatestJitterOperPacketMIA, rttMonLatestJitterOperPacketLateArrival=rttMonLatestJitterOperPacketLateArrival, rttMonLatestJitterOperSense=rttMonLatestJitterOperSense, rttMonLatestJitterErrorSenseDescription=rttMonLatestJitterErrorSenseDescription, rttMonLatestJitterOperOWSumSD=rttMonLatestJitterOperOWSumSD, rttMonLatestJitterOperOWSum2SD=rttMonLatestJitterOperOWSum2SD, rttMonLatestJitterOperOWMinSD=rttMonLatestJitterOperOWMinSD, rttMonLatestJitterOperOWMaxSD=rttMonLatestJitterOperOWMaxSD, rttMonLatestJitterOperOWSumDS=rttMonLatestJitterOperOWSumDS, rttMonLatestJitterOperOWSum2DS=rttMonLatestJitterOperOWSum2DS, rttMonLatestJitterOperOWMinDS=rttMonLatestJitterOperOWMinDS, rttMonLatestJitterOperOWMaxDS=rttMonLatestJitterOperOWMaxDS, rttMonLatestJitterOperNumOfOW=rttMonLatestJitterOperNumOfOW, rttMonLatestJitterOperMOS=rttMonLatestJitterOperMOS, rttMonLatestJitterOperICPIF=rttMonLatestJitterOperICPIF, rttMonLatestJitterOperIAJOut=rttMonLatestJitterOperIAJOut, rttMonLatestJitterOperIAJIn=rttMonLatestJitterOperIAJIn, rttMonLatestJitterOperAvgJitter=rttMonLatestJitterOperAvgJitter, rttMonLatestJitterOperAvgSDJ=rttMonLatestJitterOperAvgSDJ, rttMonLatestJitterOperAvgDSJ=rttMonLatestJitterOperAvgDSJ, rttMonLatestJitterOperOWAvgSD=rttMonLatestJitterOperOWAvgSD, rttMonLatestJitterOperOWAvgDS=rttMonLatestJitterOperOWAvgDS, rttMonLatestJitterOperNTPState=rttMonLatestJitterOperNTPState, rttMonLatestJitterOperUnSyncRTs=rttMonLatestJitterOperUnSyncRTs, rttMonLatestJitterOperRTTSumHigh=rttMonLatestJitterOperRTTSumHigh, rttMonLatestJitterOperRTTSum2High=rttMonLatestJitterOperRTTSum2High)
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonLatestJitterOperOWSumSDHigh=rttMonLatestJitterOperOWSumSDHigh, rttMonLatestJitterOperOWSum2SDHigh=rttMonLatestJitterOperOWSum2SDHigh, rttMonLatestJitterOperOWSumDSHigh=rttMonLatestJitterOperOWSumDSHigh, rttMonLatestJitterOperOWSum2DSHigh=rttMonLatestJitterOperOWSum2DSHigh, rttMonNotificationsPrefix=rttMonNotificationsPrefix, rttMonNotifications=rttMonNotifications, ciscoRttMonMibConformance=ciscoRttMonMibConformance, ciscoRttMonMibCompliances=ciscoRttMonMibCompliances, ciscoRttMonMibGroups=ciscoRttMonMibGroups)

# Notifications
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", rttMonConnectionChangeNotification=rttMonConnectionChangeNotification, rttMonTimeoutNotification=rttMonTimeoutNotification, rttMonThresholdNotification=rttMonThresholdNotification, rttMonVerifyErrorNotification=rttMonVerifyErrorNotification, rttMonNotification=rttMonNotification, rttMonLpdDiscoveryNotification=rttMonLpdDiscoveryNotification, rttMonLpdGrpStatusNotification=rttMonLpdGrpStatusNotification)

# Groups
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", ciscoStatsGroup=ciscoStatsGroup, ciscoHistoryGroup=ciscoHistoryGroup, ciscoCtrlGroupRev1=ciscoCtrlGroupRev1, ciscoCtrlGroupRev2=ciscoCtrlGroupRev2, ciscoLatestOperGroupRev1=ciscoLatestOperGroupRev1, ciscoStatsGroupRev1=ciscoStatsGroupRev1, ciscoApplGroupRev2=ciscoApplGroupRev2, ciscoCtrlGroupRev4=ciscoCtrlGroupRev4, ciscoStatsGroupRev3=ciscoStatsGroupRev3, ciscoCtrlGroupRev6=ciscoCtrlGroupRev6, ciscoStatsGroupRev4=ciscoStatsGroupRev4, ciscoNotificationGroup=ciscoNotificationGroup, ciscoApplGroupRev3=ciscoApplGroupRev3, ciscoCtrlGroupRev7=ciscoCtrlGroupRev7, ciscoCtrlGroupRev8=ciscoCtrlGroupRev8, ciscoStatsGroupRev5=ciscoStatsGroupRev5, ciscoCtrlGroupRev9=ciscoCtrlGroupRev9, ciscoCtrlGroupRev10=ciscoCtrlGroupRev10, ciscoCtrlGroupRev11=ciscoCtrlGroupRev11, ciscoNotificationGroupRev1=ciscoNotificationGroupRev1, ciscoCtrlGroupRev12=ciscoCtrlGroupRev12, ciscoCtrlGroupRev13=ciscoCtrlGroupRev13, ciscoStatsGroupRev7=ciscoStatsGroupRev7, ciscoNotificationGroupRev2=ciscoNotificationGroupRev2, ciscoApplGroupRev4=ciscoApplGroupRev4, ciscoCtrlGroupRev14=ciscoCtrlGroupRev14, ciscoCtrlGroupRev15=ciscoCtrlGroupRev15, ciscoRttMonObsoleteGroupRev1=ciscoRttMonObsoleteGroupRev1, ciscoRttMonDeprecatedGroupRev1=ciscoRttMonDeprecatedGroupRev1, ciscoCtrlGroupRev16=ciscoCtrlGroupRev16, ciscoCtrlGroupRev17=ciscoCtrlGroupRev17, ciscoCtrlGroupRev18=ciscoCtrlGroupRev18, ciscoStatsGroupRev8=ciscoStatsGroupRev8, ciscoCtrlGroupRev19=ciscoCtrlGroupRev19, ciscoCtrlGroupRev20=ciscoCtrlGroupRev20, ciscoCtrlGroupRev21=ciscoCtrlGroupRev21, ciscoCtrlGroupRev22=ciscoCtrlGroupRev22, ciscoCtrlGroupRev23=ciscoCtrlGroupRev23, ciscoCtrlGroupRev24=ciscoCtrlGroupRev24, ciscoCtrlGroupRev25=ciscoCtrlGroupRev25, ciscoStatsGroupRev2=ciscoStatsGroupRev2, ciscoCtrlGroupRev26=ciscoCtrlGroupRev26, ciscoCtrlGroupRev27=ciscoCtrlGroupRev27, ciscoCtrlGroupRev28=ciscoCtrlGroupRev28, ciscoStatsGroupRev9=ciscoStatsGroupRev9)

# Compliances
mibBuilder.exportSymbols("CISCO-RTTMON-MIB", ciscoRttMonMibComplianceRev12=ciscoRttMonMibComplianceRev12, ciscoRttMonMibComplianceRev13=ciscoRttMonMibComplianceRev13, ciscoRttMonMibComplianceRev14=ciscoRttMonMibComplianceRev14, ciscoRttMonMibComplianceRev15=ciscoRttMonMibComplianceRev15, ciscoRttMonMibComplianceRev16=ciscoRttMonMibComplianceRev16, ciscoRttMonMibComplianceRev17=ciscoRttMonMibComplianceRev17, ciscoRttMonMibComplianceRev18=ciscoRttMonMibComplianceRev18, ciscoRttMonMibComplianceRev19=ciscoRttMonMibComplianceRev19, ciscoRttMonMibComplianceRev20=ciscoRttMonMibComplianceRev20, ciscoRttMonMibComplianceRev21=ciscoRttMonMibComplianceRev21)
